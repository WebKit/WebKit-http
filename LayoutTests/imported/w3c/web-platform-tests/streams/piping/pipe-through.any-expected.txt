CONSOLE MESSAGE: Unhandled Promise Rejection: TypeError: The WritableStream.ready getter can only be used on instances of WritableStream
CONSOLE MESSAGE: Unhandled Promise Rejection: undefined

Harness Error (FAIL), message = Unhandled rejection

PASS Piping through a duck-typed pass-through transform stream should work 
FAIL Piping through a transform errored on the writable end does not cause an unhandled promise rejection c.error is not a function. (In 'c.error(new Error('this rejection should not be reported as unhandled'))', 'c.error' is undefined)
PASS pipeThrough should not call pipeTo on this 
FAIL pipeThrough should not call pipeTo on the ReadableStream prototype assert_false: the monkey-patched pipeTo should not have been called expected false got true
PASS pipeThrough should brand-check this and not allow 'null' 
FAIL pipeThrough should brand-check readable and not allow 'null' assert_throws_js: pipeThrough should brand-check readable function "() => rs.pipeThrough({
        get writable() {
          writableGetterCalled = true;
          return new WritableStream();
        },
        readable
      })" did not throw
PASS pipeThrough should brand-check this and not allow 'undefined' 
FAIL pipeThrough should brand-check readable and not allow 'undefined' assert_throws_js: pipeThrough should brand-check readable function "() => rs.pipeThrough({
        get writable() {
          writableGetterCalled = true;
          return new WritableStream();
        },
        readable
      })" did not throw
PASS pipeThrough should brand-check this and not allow '0' 
FAIL pipeThrough should brand-check readable and not allow '0' assert_throws_js: pipeThrough should brand-check readable function "() => rs.pipeThrough({
        get writable() {
          writableGetterCalled = true;
          return new WritableStream();
        },
        readable
      })" did not throw
PASS pipeThrough should brand-check this and not allow 'NaN' 
FAIL pipeThrough should brand-check readable and not allow 'NaN' assert_throws_js: pipeThrough should brand-check readable function "() => rs.pipeThrough({
        get writable() {
          writableGetterCalled = true;
          return new WritableStream();
        },
        readable
      })" did not throw
PASS pipeThrough should brand-check this and not allow 'true' 
FAIL pipeThrough should brand-check readable and not allow 'true' assert_throws_js: pipeThrough should brand-check readable function "() => rs.pipeThrough({
        get writable() {
          writableGetterCalled = true;
          return new WritableStream();
        },
        readable
      })" did not throw
PASS pipeThrough should brand-check this and not allow 'ReadableStream' 
FAIL pipeThrough should brand-check readable and not allow 'ReadableStream' assert_throws_js: pipeThrough should brand-check readable function "() => rs.pipeThrough({
        get writable() {
          writableGetterCalled = true;
          return new WritableStream();
        },
        readable
      })" did not throw
PASS pipeThrough should brand-check this and not allow '[object ReadableStream]' 
FAIL pipeThrough should brand-check readable and not allow '[object ReadableStream]' assert_throws_js: pipeThrough should brand-check readable function "() => rs.pipeThrough({
        get writable() {
          writableGetterCalled = true;
          return new WritableStream();
        },
        readable
      })" did not throw
PASS pipeThrough should brand-check writable and not allow 'null' 
PASS pipeThrough should brand-check writable and not allow 'undefined' 
PASS pipeThrough should brand-check writable and not allow '0' 
PASS pipeThrough should brand-check writable and not allow 'NaN' 
PASS pipeThrough should brand-check writable and not allow 'true' 
PASS pipeThrough should brand-check writable and not allow 'WritableStream' 
FAIL pipeThrough should brand-check writable and not allow '[object WritableStream]' assert_throws_js: pipeThrough should brand-check writable function "() => rs.pipeThrough({
      get readable() {
        readableGetterCalled = true;
        return new ReadableStream();
      },
      writable
    })" did not throw
PASS pipeThrough should rethrow errors from accessing readable or writable 
FAIL invalid values of signal should throw; specifically 'null' assert_throws_js: pipeThrough should throw function "() => rs.pipeThrough(uninterestingReadableWritablePair(), { signal })" did not throw
FAIL invalid values of signal should throw; specifically '0' assert_throws_js: pipeThrough should throw function "() => rs.pipeThrough(uninterestingReadableWritablePair(), { signal })" did not throw
FAIL invalid values of signal should throw; specifically 'NaN' assert_throws_js: pipeThrough should throw function "() => rs.pipeThrough(uninterestingReadableWritablePair(), { signal })" did not throw
FAIL invalid values of signal should throw; specifically 'true' assert_throws_js: pipeThrough should throw function "() => rs.pipeThrough(uninterestingReadableWritablePair(), { signal })" did not throw
FAIL invalid values of signal should throw; specifically 'AbortSignal' assert_throws_js: pipeThrough should throw function "() => rs.pipeThrough(uninterestingReadableWritablePair(), { signal })" did not throw
FAIL invalid values of signal should throw; specifically '[object AbortSignal]' assert_throws_js: pipeThrough should throw function "() => rs.pipeThrough(uninterestingReadableWritablePair(), { signal })" did not throw
PASS pipeThrough should accept a real AbortSignal 
PASS pipeThrough should throw if this is locked 
FAIL pipeThrough should throw if writable is locked writable.getWriter is not a function. (In 'writable.getWriter()', 'writable.getWriter' is undefined)
PASS pipeThrough should not care if readable is locked 
FAIL preventCancel should work controller.error is not a function. (In 'controller.error()', 'controller.error' is undefined)
PASS preventClose should work 
PASS preventAbort should work 
PASS pipeThrough() should throw if an option getter grabs a writer 

