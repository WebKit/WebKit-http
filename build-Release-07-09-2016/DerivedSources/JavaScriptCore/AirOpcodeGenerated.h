// Generated by opcode_generator.rb from /home/naveen/workspace/ML_03/buildroot-wpe/output/build/wpe-9d4c9c472778d89386fa3533f95f6b8e8c203894/Source/JavaScriptCore/b3/air/AirOpcode.opcodes -- do not edit!
#ifndef AirOpcodeGenerated_h
#define AirOpcodeGenerated_h
#include "AirInstInlines.h"
#include "wtf/PrintStream.h"
namespace WTF {
using namespace JSC::B3::Air;
void printInternal(PrintStream& out, Opcode opcode)
{
    switch (opcode) {
    case Nop:
        out.print("Nop");
        return;
    case Add32:
        out.print("Add32");
        return;
    case Add8:
        out.print("Add8");
        return;
    case Add16:
        out.print("Add16");
        return;
    case Add64:
        out.print("Add64");
        return;
    case AddDouble:
        out.print("AddDouble");
        return;
    case AddFloat:
        out.print("AddFloat");
        return;
    case Sub32:
        out.print("Sub32");
        return;
    case Sub64:
        out.print("Sub64");
        return;
    case SubDouble:
        out.print("SubDouble");
        return;
    case SubFloat:
        out.print("SubFloat");
        return;
    case Neg32:
        out.print("Neg32");
        return;
    case Neg64:
        out.print("Neg64");
        return;
    case NegateDouble:
        out.print("NegateDouble");
        return;
    case Mul32:
        out.print("Mul32");
        return;
    case Mul64:
        out.print("Mul64");
        return;
    case MultiplyAdd32:
        out.print("MultiplyAdd32");
        return;
    case MultiplyAdd64:
        out.print("MultiplyAdd64");
        return;
    case MultiplySub32:
        out.print("MultiplySub32");
        return;
    case MultiplySub64:
        out.print("MultiplySub64");
        return;
    case MultiplyNeg32:
        out.print("MultiplyNeg32");
        return;
    case MultiplyNeg64:
        out.print("MultiplyNeg64");
        return;
    case Div32:
        out.print("Div32");
        return;
    case Div64:
        out.print("Div64");
        return;
    case MulDouble:
        out.print("MulDouble");
        return;
    case MulFloat:
        out.print("MulFloat");
        return;
    case DivDouble:
        out.print("DivDouble");
        return;
    case DivFloat:
        out.print("DivFloat");
        return;
    case X86ConvertToDoubleWord32:
        out.print("X86ConvertToDoubleWord32");
        return;
    case X86ConvertToQuadWord64:
        out.print("X86ConvertToQuadWord64");
        return;
    case X86Div32:
        out.print("X86Div32");
        return;
    case X86Div64:
        out.print("X86Div64");
        return;
    case Lea:
        out.print("Lea");
        return;
    case And32:
        out.print("And32");
        return;
    case And64:
        out.print("And64");
        return;
    case AndDouble:
        out.print("AndDouble");
        return;
    case AndFloat:
        out.print("AndFloat");
        return;
    case XorDouble:
        out.print("XorDouble");
        return;
    case XorFloat:
        out.print("XorFloat");
        return;
    case Lshift32:
        out.print("Lshift32");
        return;
    case Lshift64:
        out.print("Lshift64");
        return;
    case Rshift32:
        out.print("Rshift32");
        return;
    case Rshift64:
        out.print("Rshift64");
        return;
    case Urshift32:
        out.print("Urshift32");
        return;
    case Urshift64:
        out.print("Urshift64");
        return;
    case Or32:
        out.print("Or32");
        return;
    case Or64:
        out.print("Or64");
        return;
    case Xor32:
        out.print("Xor32");
        return;
    case Xor64:
        out.print("Xor64");
        return;
    case Not32:
        out.print("Not32");
        return;
    case Not64:
        out.print("Not64");
        return;
    case AbsDouble:
        out.print("AbsDouble");
        return;
    case AbsFloat:
        out.print("AbsFloat");
        return;
    case CeilDouble:
        out.print("CeilDouble");
        return;
    case CeilFloat:
        out.print("CeilFloat");
        return;
    case FloorDouble:
        out.print("FloorDouble");
        return;
    case FloorFloat:
        out.print("FloorFloat");
        return;
    case SqrtDouble:
        out.print("SqrtDouble");
        return;
    case SqrtFloat:
        out.print("SqrtFloat");
        return;
    case ConvertInt32ToDouble:
        out.print("ConvertInt32ToDouble");
        return;
    case ConvertInt64ToDouble:
        out.print("ConvertInt64ToDouble");
        return;
    case ConvertInt32ToFloat:
        out.print("ConvertInt32ToFloat");
        return;
    case ConvertInt64ToFloat:
        out.print("ConvertInt64ToFloat");
        return;
    case CountLeadingZeros32:
        out.print("CountLeadingZeros32");
        return;
    case CountLeadingZeros64:
        out.print("CountLeadingZeros64");
        return;
    case ConvertDoubleToFloat:
        out.print("ConvertDoubleToFloat");
        return;
    case ConvertFloatToDouble:
        out.print("ConvertFloatToDouble");
        return;
    case Move:
        out.print("Move");
        return;
    case Swap32:
        out.print("Swap32");
        return;
    case Swap64:
        out.print("Swap64");
        return;
    case Move32:
        out.print("Move32");
        return;
    case StoreZero32:
        out.print("StoreZero32");
        return;
    case SignExtend32ToPtr:
        out.print("SignExtend32ToPtr");
        return;
    case ZeroExtend8To32:
        out.print("ZeroExtend8To32");
        return;
    case SignExtend8To32:
        out.print("SignExtend8To32");
        return;
    case ZeroExtend16To32:
        out.print("ZeroExtend16To32");
        return;
    case SignExtend16To32:
        out.print("SignExtend16To32");
        return;
    case MoveFloat:
        out.print("MoveFloat");
        return;
    case MoveDouble:
        out.print("MoveDouble");
        return;
    case MoveZeroToDouble:
        out.print("MoveZeroToDouble");
        return;
    case Move64ToDouble:
        out.print("Move64ToDouble");
        return;
    case Move32ToFloat:
        out.print("Move32ToFloat");
        return;
    case MoveDoubleTo64:
        out.print("MoveDoubleTo64");
        return;
    case MoveFloatTo32:
        out.print("MoveFloatTo32");
        return;
    case Load8:
        out.print("Load8");
        return;
    case Store8:
        out.print("Store8");
        return;
    case Load8SignedExtendTo32:
        out.print("Load8SignedExtendTo32");
        return;
    case Load16:
        out.print("Load16");
        return;
    case Load16SignedExtendTo32:
        out.print("Load16SignedExtendTo32");
        return;
    case Store16:
        out.print("Store16");
        return;
    case Compare32:
        out.print("Compare32");
        return;
    case Compare64:
        out.print("Compare64");
        return;
    case Test32:
        out.print("Test32");
        return;
    case Test64:
        out.print("Test64");
        return;
    case CompareDouble:
        out.print("CompareDouble");
        return;
    case CompareFloat:
        out.print("CompareFloat");
        return;
    case Branch8:
        out.print("Branch8");
        return;
    case Branch32:
        out.print("Branch32");
        return;
    case Branch64:
        out.print("Branch64");
        return;
    case BranchTest8:
        out.print("BranchTest8");
        return;
    case BranchTest32:
        out.print("BranchTest32");
        return;
    case BranchTest64:
        out.print("BranchTest64");
        return;
    case BranchDouble:
        out.print("BranchDouble");
        return;
    case BranchFloat:
        out.print("BranchFloat");
        return;
    case BranchAdd32:
        out.print("BranchAdd32");
        return;
    case BranchAdd64:
        out.print("BranchAdd64");
        return;
    case BranchMul32:
        out.print("BranchMul32");
        return;
    case BranchMul64:
        out.print("BranchMul64");
        return;
    case BranchSub32:
        out.print("BranchSub32");
        return;
    case BranchSub64:
        out.print("BranchSub64");
        return;
    case BranchNeg32:
        out.print("BranchNeg32");
        return;
    case BranchNeg64:
        out.print("BranchNeg64");
        return;
    case MoveConditionally32:
        out.print("MoveConditionally32");
        return;
    case MoveConditionally64:
        out.print("MoveConditionally64");
        return;
    case MoveConditionallyTest32:
        out.print("MoveConditionallyTest32");
        return;
    case MoveConditionallyTest64:
        out.print("MoveConditionallyTest64");
        return;
    case MoveConditionallyDouble:
        out.print("MoveConditionallyDouble");
        return;
    case MoveConditionallyFloat:
        out.print("MoveConditionallyFloat");
        return;
    case MoveDoubleConditionally32:
        out.print("MoveDoubleConditionally32");
        return;
    case MoveDoubleConditionally64:
        out.print("MoveDoubleConditionally64");
        return;
    case MoveDoubleConditionallyTest32:
        out.print("MoveDoubleConditionallyTest32");
        return;
    case MoveDoubleConditionallyTest64:
        out.print("MoveDoubleConditionallyTest64");
        return;
    case MoveDoubleConditionallyDouble:
        out.print("MoveDoubleConditionallyDouble");
        return;
    case MoveDoubleConditionallyFloat:
        out.print("MoveDoubleConditionallyFloat");
        return;
    case Jump:
        out.print("Jump");
        return;
    case Ret32:
        out.print("Ret32");
        return;
    case Ret64:
        out.print("Ret64");
        return;
    case RetFloat:
        out.print("RetFloat");
        return;
    case RetDouble:
        out.print("RetDouble");
        return;
    case Oops:
        out.print("Oops");
        return;
    case Shuffle:
        out.print("Shuffle");
        return;
    case Patch:
        out.print("Patch");
        return;
    case CCall:
        out.print("CCall");
        return;
    case ColdCCall:
        out.print("ColdCCall");
        return;
    }
    RELEASE_ASSERT_NOT_REACHED();
}
} // namespace WTF
namespace JSC { namespace B3 { namespace Air {
bool Inst::isValidForm()
{
switch (this->opcode) {
case Nop:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Add32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Add8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Add16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Sub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Sub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Neg32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Neg64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case NegateDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Mul64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MultiplyAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MultiplyAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MultiplySub32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MultiplySub64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MultiplyNeg32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MultiplyNeg64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case DivDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case DivFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case X86ConvertToDoubleWord32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToDoubleWord32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case X86ConvertToQuadWord64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToQuadWord64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case X86Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case X86Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Lea:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (args[0].isStack() && args[0].stackSlot()->isSpill())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case And32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case And64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AndDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AndFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case XorDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case XorFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Or32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Or64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Xor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Xor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Not32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Not64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case AbsDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case AbsFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CeilDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CeilFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case FloorDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case FloorFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SqrtDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SqrtFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertInt32ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertInt64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertInt32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertInt64ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CountLeadingZeros32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CountLeadingZeros64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertDoubleToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ConvertFloatToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Move:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::pointerWidth()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::pointerWidth()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Swap32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Swap64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Move32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case StoreZero32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend32ToPtr:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ZeroExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case ZeroExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveZeroToDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Move64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Move32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleTo64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveFloatTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Store8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load8SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load16SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Arg::Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Store16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Compare32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Compare64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Test32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Test64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CompareDouble:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case CompareFloat:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Branch8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Branch32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Imm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Branch64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchTest8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width8))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchTest32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::BitImm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchTest64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImm64Form(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchMul64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchSub32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchSub64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchNeg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchNeg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionally32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionally64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyDouble:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyFloat:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionally32:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionally64:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest32:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest64:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Arg::Width64))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionallyDouble:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDoubleConditionallyFloat:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Jump:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Ret32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Ret64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case RetFloat:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case RetDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Oops:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Shuffle:
OPGEN_RETURN(ShuffleCustom::isValidForm(*this));
break;
case Patch:
OPGEN_RETURN(PatchCustom::isValidForm(*this));
break;
case CCall:
OPGEN_RETURN(CCallCustom::isValidForm(*this));
break;
case ColdCCall:
OPGEN_RETURN(ColdCCallCustom::isValidForm(*this));
break;
default:
break;
}
return false;
}
bool Inst::admitsStack(unsigned argIndex)
{
switch (opcode) {
case Nop:
switch (argIndex) {
default:
break;
}
break;
case Add32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Add8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Add16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Add64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AddDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AddFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Sub32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case Sub64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case SubDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SubFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Neg32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Neg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case NegateDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Mul32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Mul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MultiplyAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MultiplyAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MultiplySub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MultiplySub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MultiplyNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MultiplyNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MulDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MulFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case DivDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case DivFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case X86ConvertToDoubleWord32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case X86ConvertToQuadWord64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case X86Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case X86Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Lea:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case And32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case And64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AndDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AndFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case XorDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case XorFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Lshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Lshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Rshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Rshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Urshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Urshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Or32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Or64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Xor32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Xor64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Not32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Not64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AbsDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case AbsFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CeilDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CeilFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case FloorDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case FloorFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SqrtDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SqrtFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertInt32ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertInt64ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertInt32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertInt64ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CountLeadingZeros32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CountLeadingZeros64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertDoubleToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ConvertFloatToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Move:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
#if USE(JSVALUE64)
case Arg::BigImm:
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Swap32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Swap64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Move32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::Imm:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case StoreZero32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case SignExtend32ToPtr:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ZeroExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SignExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case ZeroExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case SignExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveZeroToDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Move64ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Move32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleTo64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveFloatTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Load8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Store8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Load8SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Load16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Load16SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Store16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Compare32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Compare64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Test32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Test64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CompareDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case CompareFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Branch8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Branch32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Branch64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchTest8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Imm:
break;
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchMul32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchMul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchSub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchSub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case BranchNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case MoveDoubleConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Jump:
switch (argIndex) {
default:
break;
}
break;
case Ret32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Ret64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case RetFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case RetDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Oops:
switch (argIndex) {
default:
break;
}
break;
case Shuffle:
OPGEN_RETURN(ShuffleCustom::admitsStack(*this, argIndex));
break;
case Patch:
OPGEN_RETURN(PatchCustom::admitsStack(*this, argIndex));
break;
case CCall:
OPGEN_RETURN(CCallCustom::admitsStack(*this, argIndex));
break;
case ColdCCall:
OPGEN_RETURN(ColdCCallCustom::admitsStack(*this, argIndex));
break;
default:
break;
}
return false;
}
bool Inst::hasNonArgNonControlEffects()
{
switch (opcode) {
case Shuffle:
return ShuffleCustom::hasNonArgNonControlEffects(*this);
case Patch:
return PatchCustom::hasNonArgNonControlEffects(*this);
case CCall:
return CCallCustom::hasNonArgNonControlEffects(*this);
case ColdCCall:
return ColdCCallCustom::hasNonArgNonControlEffects(*this);
default:
return false;
}
}
bool Inst::hasNonArgEffects()
{
switch (opcode) {
case Branch8:
case Branch32:
case Branch64:
case BranchTest8:
case BranchTest32:
case BranchTest64:
case BranchDouble:
case BranchFloat:
case BranchAdd32:
case BranchAdd64:
case BranchMul32:
case BranchMul64:
case BranchSub32:
case BranchSub64:
case BranchNeg32:
case BranchNeg64:
case Jump:
case Ret32:
case Ret64:
case RetFloat:
case RetDouble:
case Oops:
return true;
case Shuffle:
return ShuffleCustom::hasNonArgNonControlEffects(*this);
case Patch:
return PatchCustom::hasNonArgNonControlEffects(*this);
case CCall:
return CCallCustom::hasNonArgNonControlEffects(*this);
case ColdCCall:
return ColdCCallCustom::hasNonArgNonControlEffects(*this);
default:
return false;
}
}
CCallHelpers::Jump Inst::generate(CCallHelpers& jit, GenerationContext& context)
{
UNUSED_PARAM(jit);
UNUSED_PARAM(context);
CCallHelpers::Jump result;
switch (this->opcode) {
case Nop:
jit.nop();
OPGEN_RETURN(result);
break;
break;
case Add32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
jit.add32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.add32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Add8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Add16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.addDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.addFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Sub32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.sub32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.sub32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Sub64:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.sub64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.sub64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.subDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].asBaseIndex(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.subFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].asBaseIndex(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Neg32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.neg32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.neg32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Neg64:
#if CPU(X86_64) || CPU(ARM64)
jit.neg64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case NegateDouble:
#if CPU(ARM64)
jit.negateDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Mul64:
switch (this->args.size()) {
case 2:
#if CPU(X86_64) || CPU(ARM64)
jit.mul64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 3:
jit.mul64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MultiplyAdd32:
#if CPU(ARM64)
jit.multiplyAdd32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MultiplyAdd64:
#if CPU(ARM64)
jit.multiplyAdd64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MultiplySub32:
#if CPU(ARM64)
jit.multiplySub32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MultiplySub64:
#if CPU(ARM64)
jit.multiplySub64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MultiplyNeg32:
#if CPU(ARM64)
jit.multiplyNeg32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MultiplyNeg64:
#if CPU(ARM64)
jit.multiplyNeg64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Div32:
#if CPU(ARM64)
jit.div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Div64:
#if CPU(ARM64)
jit.div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mulDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mulFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case DivDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.divDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.divDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.divDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case DivFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.divFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.divFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.divFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case X86ConvertToDoubleWord32:
#if CPU(X86) || CPU(X86_64)
jit.x86ConvertToDoubleWord32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case X86ConvertToQuadWord64:
#if CPU(X86_64)
jit.x86ConvertToQuadWord64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case X86Div32:
#if CPU(X86) || CPU(X86_64)
jit.x86Div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case X86Div64:
#if CPU(X86_64)
jit.x86Div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Lea:
jit.lea(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case And32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.and32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case And64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.and64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.and64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.and64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.and64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case AndDouble:
switch (this->args.size()) {
case 3:
jit.andDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.andDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case AndFloat:
switch (this->args.size()) {
case 3:
jit.andFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.andFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case XorDouble:
switch (this->args.size()) {
case 3:
#if CPU(X86) || CPU(X86_64)
jit.xorDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.xorDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case XorFloat:
switch (this->args.size()) {
case 3:
#if CPU(X86) || CPU(X86_64)
jit.xorFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.xorFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.lshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.lshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.lshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.lshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.lshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.lshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.lshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.lshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.rshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.rshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.urshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.urshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.urshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.urshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.urshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.urshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.urshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.urshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Or32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.or32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Or64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.or64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.or64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.or64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.or64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Xor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.xor32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Xor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.xor64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.xor64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.xor64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xor64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
#if CPU(X86_64)
jit.xor64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Not32:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
jit.not32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Not64:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
jit.not64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.not64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.not64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case AbsDouble:
#if CPU(ARM64)
jit.absDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case AbsFloat:
#if CPU(ARM64)
jit.absFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case CeilDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.ceilDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case CeilFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.ceilFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case FloorDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.floorDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.floorDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case FloorFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.floorFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.floorFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case SqrtDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sqrtDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case SqrtFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sqrtFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertInt32ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertInt32ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertInt64ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.convertInt64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.convertInt64ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertInt32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertInt32ToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertInt64ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.convertInt64ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.convertInt64ToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case CountLeadingZeros32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.countLeadingZeros32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.countLeadingZeros32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case CountLeadingZeros64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.countLeadingZeros64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.countLeadingZeros64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertDoubleToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertDoubleToFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertDoubleToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ConvertFloatToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertFloatToDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertFloatToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Move:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.move(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storePtr(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storePtr(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.signExtend32ToPtr(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storePtr(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
jit.move(args[0].asTrustedImm64(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadPtr(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadPtr(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Swap32:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.swap32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.swap32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Swap64:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.swap64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.swap64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Move32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.zeroExtend32ToPtr(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.store32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.zeroExtend32ToPtr(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case StoreZero32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeZero32(args[0].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeZero32(args[0].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case SignExtend32ToPtr:
jit.signExtend32ToPtr(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case ZeroExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case SignExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case ZeroExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case SignExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeFloat(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeFloat(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeDouble(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeDouble(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveZeroToDouble:
jit.moveZeroToDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Move64ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.move64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Move32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.move32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveDoubleTo64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleTo64(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
jit.load64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.load64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveFloatTo32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.moveFloatTo32(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Load8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Store8:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Load8SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Load16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Load16SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Store16:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Compare32:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Compare64:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Test32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.test32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Test64:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case CompareDouble:
jit.compareDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case CompareFloat:
jit.compareFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Branch8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branch8(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branch8(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Branch32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Branch64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchTest8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest8(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest8(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm64());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchDouble:
result = jit.branchDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case BranchFloat:
result = jit.branchFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case BranchAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 4:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
#if CPU(ARM64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchMul64:
switch (this->args.size()) {
case 3:
#if CPU(X86_64)
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
#if CPU(ARM64)
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchSub32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchSub64:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchSub64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchSub64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case BranchNeg32:
result = jit.branchNeg32(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case BranchNeg64:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchNeg64(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case MoveConditionally32:
switch (this->args.size()) {
case 5:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionally64:
switch (this->args.size()) {
case 5:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case MoveConditionallyDouble:
switch (this->args.size()) {
case 6:
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case 5:
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveConditionallyFloat:
switch (this->args.size()) {
case 6:
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case 5:
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case MoveDoubleConditionally32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveDoubleConditionally64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveDoubleConditionallyTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case MoveDoubleConditionallyDouble:
jit.moveDoubleConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case MoveDoubleConditionallyFloat:
jit.moveDoubleConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Jump:
result = jit.jump();
OPGEN_RETURN(result);
break;
break;
case Ret32:
jit.ret32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Ret64:
#if CPU(X86_64) || CPU(ARM64)
jit.ret64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case RetFloat:
jit.retFloat(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case RetDouble:
jit.retDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Oops:
jit.oops();
OPGEN_RETURN(result);
break;
break;
case Shuffle:
OPGEN_RETURN(ShuffleCustom::generate(*this, jit, context));
break;
case Patch:
OPGEN_RETURN(PatchCustom::generate(*this, jit, context));
break;
case CCall:
OPGEN_RETURN(CCallCustom::generate(*this, jit, context));
break;
case ColdCCall:
OPGEN_RETURN(ColdCCallCustom::generate(*this, jit, context));
break;
default:
break;
}
RELEASE_ASSERT_NOT_REACHED();
return result;
}
} } } // namespace JSC::B3::Air
#endif // AirOpcodeGenerated_h
