/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(WEBGL)

#include "JSWebGLRenderingContextBase.h"

#include "ExceptionCode.h"
#include "JSDOMBinding.h"
#include "JSDOMConvert.h"
#include "JSHTMLCanvasElement.h"
#include "JSHTMLImageElement.h"
#include "JSHTMLVideoElement.h"
#include "JSImageData.h"
#include "JSWebGLActiveInfo.h"
#include "JSWebGLBuffer.h"
#include "JSWebGLContextAttributes.h"
#include "JSWebGLFramebuffer.h"
#include "JSWebGLProgram.h"
#include "JSWebGLRenderbuffer.h"
#include "JSWebGLShader.h"
#include "JSWebGLShaderPrecisionFormat.h"
#include "JSWebGLTexture.h"
#include "JSWebGLUniformLocation.h"
#include "URL.h"
#include "WebGLActiveInfo.h"
#include "WebGLBuffer.h"
#include "WebGLContextAttributes.h"
#include "WebGLFramebuffer.h"
#include "WebGLProgram.h"
#include "WebGLRenderbuffer.h"
#include "WebGLShader.h"
#include "WebGLShaderPrecisionFormat.h"
#include "WebGLTexture.h"
#include "WebGLUniformLocation.h"
#include <runtime/Error.h>
#include <wtf/GetPtr.h>

using namespace JSC;

namespace WebCore {

// Functions

JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionActiveTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionAttachShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendColor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendEquation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendFunc(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBufferData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBufferSubData(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatus(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClear(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearColor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearDepth(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearStencil(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionColorMask(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompileShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCullFace(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthFunc(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthMask(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthRange(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDetachShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDisable(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDrawArrays(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDrawElements(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionEnable(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArray(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFinish(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFlush(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFrontFace(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmap(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttrib(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShaders(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributes(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetError(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetExtension(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLog(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLog(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormat(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderSource(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensions(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetTexParameter(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetUniform(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocation(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttrib(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffset(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionHint(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsBuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsContextLost(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsEnabled(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsFramebuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsRenderbuffer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsShader(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsTexture(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionLineWidth(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionLinkProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionPixelStorei(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionPolygonOffset(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionReadPixels(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompiler(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorage(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionSampleCoverage(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionScissor(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionShaderSource(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilFunc(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilMask(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilOp(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparate(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexParameterf(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexParameteri(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4i(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4iv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUseProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionValidateProgram(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4f(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fv(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointer(JSC::ExecState*);
JSC::EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionViewport(JSC::ExecState*);

// Attributes

JSC::EncodedJSValue jsWebGLRenderingContextBaseDrawingBufferWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
JSC::EncodedJSValue jsWebGLRenderingContextBaseDrawingBufferHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
bool setJSWebGLRenderingContextBaseConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);

class JSWebGLRenderingContextBasePrototype : public JSC::JSNonFinalObject {
public:
    typedef JSC::JSNonFinalObject Base;
    static JSWebGLRenderingContextBasePrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
    {
        JSWebGLRenderingContextBasePrototype* ptr = new (NotNull, JSC::allocateCell<JSWebGLRenderingContextBasePrototype>(vm.heap)) JSWebGLRenderingContextBasePrototype(vm, globalObject, structure);
        ptr->finishCreation(vm);
        return ptr;
    }

    DECLARE_INFO;
    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
    {
        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
    }

private:
    JSWebGLRenderingContextBasePrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
        : JSC::JSNonFinalObject(vm, structure)
    {
    }

    void finishCreation(JSC::VM&);
};

/* Hash table for prototype */

static const HashTableValue JSWebGLRenderingContextBasePrototypeTableValues[] =
{
    { "drawingBufferWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsWebGLRenderingContextBaseDrawingBufferWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "drawingBufferHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsWebGLRenderingContextBaseDrawingBufferHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
    { "activeTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionActiveTexture), (intptr_t) (1) } },
    { "attachShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionAttachShader), (intptr_t) (2) } },
    { "bindAttribLocation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocation), (intptr_t) (3) } },
    { "bindBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindBuffer), (intptr_t) (2) } },
    { "bindFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindFramebuffer), (intptr_t) (2) } },
    { "bindRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindRenderbuffer), (intptr_t) (2) } },
    { "bindTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBindTexture), (intptr_t) (2) } },
    { "blendColor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendColor), (intptr_t) (4) } },
    { "blendEquation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendEquation), (intptr_t) (1) } },
    { "blendEquationSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparate), (intptr_t) (2) } },
    { "blendFunc", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendFunc), (intptr_t) (2) } },
    { "blendFuncSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparate), (intptr_t) (4) } },
    { "bufferData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBufferData), (intptr_t) (3) } },
    { "bufferSubData", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionBufferSubData), (intptr_t) (3) } },
    { "checkFramebufferStatus", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatus), (intptr_t) (1) } },
    { "clear", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionClear), (intptr_t) (1) } },
    { "clearColor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionClearColor), (intptr_t) (4) } },
    { "clearDepth", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionClearDepth), (intptr_t) (1) } },
    { "clearStencil", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionClearStencil), (intptr_t) (1) } },
    { "colorMask", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionColorMask), (intptr_t) (4) } },
    { "compileShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCompileShader), (intptr_t) (1) } },
    { "compressedTexImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2D), (intptr_t) (7) } },
    { "compressedTexSubImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2D), (intptr_t) (8) } },
    { "copyTexImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2D), (intptr_t) (8) } },
    { "copyTexSubImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2D), (intptr_t) (8) } },
    { "createBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateBuffer), (intptr_t) (0) } },
    { "createFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateFramebuffer), (intptr_t) (0) } },
    { "createProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateProgram), (intptr_t) (0) } },
    { "createRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbuffer), (intptr_t) (0) } },
    { "createShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateShader), (intptr_t) (1) } },
    { "createTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCreateTexture), (intptr_t) (0) } },
    { "cullFace", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionCullFace), (intptr_t) (1) } },
    { "deleteBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteBuffer), (intptr_t) (1) } },
    { "deleteFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebuffer), (intptr_t) (1) } },
    { "deleteProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteProgram), (intptr_t) (1) } },
    { "deleteRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbuffer), (intptr_t) (1) } },
    { "deleteShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteShader), (intptr_t) (1) } },
    { "deleteTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDeleteTexture), (intptr_t) (1) } },
    { "depthFunc", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDepthFunc), (intptr_t) (1) } },
    { "depthMask", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDepthMask), (intptr_t) (1) } },
    { "depthRange", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDepthRange), (intptr_t) (2) } },
    { "detachShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDetachShader), (intptr_t) (2) } },
    { "disable", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDisable), (intptr_t) (1) } },
    { "disableVertexAttribArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArray), (intptr_t) (1) } },
    { "drawArrays", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDrawArrays), (intptr_t) (3) } },
    { "drawElements", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionDrawElements), (intptr_t) (4) } },
    { "enable", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionEnable), (intptr_t) (1) } },
    { "enableVertexAttribArray", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArray), (intptr_t) (1) } },
    { "finish", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFinish), (intptr_t) (0) } },
    { "flush", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFlush), (intptr_t) (0) } },
    { "framebufferRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbuffer), (intptr_t) (4) } },
    { "framebufferTexture2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2D), (intptr_t) (5) } },
    { "frontFace", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionFrontFace), (intptr_t) (1) } },
    { "generateMipmap", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmap), (intptr_t) (1) } },
    { "getActiveAttrib", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttrib), (intptr_t) (2) } },
    { "getActiveUniform", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniform), (intptr_t) (2) } },
    { "getAttachedShaders", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShaders), (intptr_t) (1) } },
    { "getAttribLocation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocation), (intptr_t) (2) } },
    { "getBufferParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameter), (intptr_t) (2) } },
    { "getContextAttributes", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributes), (intptr_t) (0) } },
    { "getError", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetError), (intptr_t) (0) } },
    { "getExtension", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetExtension), (intptr_t) (1) } },
    { "getFramebufferAttachmentParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameter), (intptr_t) (3) } },
    { "getParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetParameter), (intptr_t) (1) } },
    { "getProgramParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameter), (intptr_t) (2) } },
    { "getProgramInfoLog", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLog), (intptr_t) (1) } },
    { "getRenderbufferParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameter), (intptr_t) (2) } },
    { "getShaderParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameter), (intptr_t) (2) } },
    { "getShaderInfoLog", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLog), (intptr_t) (1) } },
    { "getShaderPrecisionFormat", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormat), (intptr_t) (2) } },
    { "getShaderSource", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetShaderSource), (intptr_t) (1) } },
    { "getSupportedExtensions", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensions), (intptr_t) (0) } },
    { "getTexParameter", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetTexParameter), (intptr_t) (2) } },
    { "getUniform", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetUniform), (intptr_t) (2) } },
    { "getUniformLocation", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocation), (intptr_t) (2) } },
    { "getVertexAttrib", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttrib), (intptr_t) (2) } },
    { "getVertexAttribOffset", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffset), (intptr_t) (2) } },
    { "hint", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionHint), (intptr_t) (2) } },
    { "isBuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsBuffer), (intptr_t) (1) } },
    { "isContextLost", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsContextLost), (intptr_t) (0) } },
    { "isEnabled", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsEnabled), (intptr_t) (1) } },
    { "isFramebuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsFramebuffer), (intptr_t) (1) } },
    { "isProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsProgram), (intptr_t) (1) } },
    { "isRenderbuffer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsRenderbuffer), (intptr_t) (1) } },
    { "isShader", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsShader), (intptr_t) (1) } },
    { "isTexture", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionIsTexture), (intptr_t) (1) } },
    { "lineWidth", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionLineWidth), (intptr_t) (1) } },
    { "linkProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionLinkProgram), (intptr_t) (1) } },
    { "pixelStorei", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionPixelStorei), (intptr_t) (2) } },
    { "polygonOffset", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionPolygonOffset), (intptr_t) (2) } },
    { "readPixels", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionReadPixels), (intptr_t) (7) } },
    { "releaseShaderCompiler", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompiler), (intptr_t) (0) } },
    { "renderbufferStorage", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorage), (intptr_t) (4) } },
    { "sampleCoverage", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionSampleCoverage), (intptr_t) (2) } },
    { "scissor", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionScissor), (intptr_t) (4) } },
    { "shaderSource", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionShaderSource), (intptr_t) (2) } },
    { "stencilFunc", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilFunc), (intptr_t) (3) } },
    { "stencilFuncSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparate), (intptr_t) (4) } },
    { "stencilMask", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilMask), (intptr_t) (1) } },
    { "stencilMaskSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparate), (intptr_t) (2) } },
    { "stencilOp", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilOp), (intptr_t) (3) } },
    { "stencilOpSeparate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparate), (intptr_t) (4) } },
    { "texParameterf", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionTexParameterf), (intptr_t) (3) } },
    { "texParameteri", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionTexParameteri), (intptr_t) (3) } },
    { "texImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionTexImage2D), (intptr_t) (9) } },
    { "texSubImage2D", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D), (intptr_t) (9) } },
    { "uniform1f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform1f), (intptr_t) (2) } },
    { "uniform1fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform1fv), (intptr_t) (2) } },
    { "uniform1i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform1i), (intptr_t) (2) } },
    { "uniform1iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform1iv), (intptr_t) (2) } },
    { "uniform2f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform2f), (intptr_t) (3) } },
    { "uniform2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform2fv), (intptr_t) (2) } },
    { "uniform2i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform2i), (intptr_t) (3) } },
    { "uniform2iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform2iv), (intptr_t) (2) } },
    { "uniform3f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform3f), (intptr_t) (4) } },
    { "uniform3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform3fv), (intptr_t) (2) } },
    { "uniform3i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform3i), (intptr_t) (4) } },
    { "uniform3iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform3iv), (intptr_t) (2) } },
    { "uniform4f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform4f), (intptr_t) (5) } },
    { "uniform4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform4fv), (intptr_t) (2) } },
    { "uniform4i", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform4i), (intptr_t) (5) } },
    { "uniform4iv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniform4iv), (intptr_t) (2) } },
    { "uniformMatrix2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fv), (intptr_t) (3) } },
    { "uniformMatrix3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fv), (intptr_t) (3) } },
    { "uniformMatrix4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fv), (intptr_t) (3) } },
    { "useProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionUseProgram), (intptr_t) (1) } },
    { "validateProgram", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionValidateProgram), (intptr_t) (1) } },
    { "vertexAttrib1f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1f), (intptr_t) (2) } },
    { "vertexAttrib1fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fv), (intptr_t) (2) } },
    { "vertexAttrib2f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2f), (intptr_t) (3) } },
    { "vertexAttrib2fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fv), (intptr_t) (2) } },
    { "vertexAttrib3f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3f), (intptr_t) (4) } },
    { "vertexAttrib3fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fv), (intptr_t) (2) } },
    { "vertexAttrib4f", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4f), (intptr_t) (5) } },
    { "vertexAttrib4fv", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fv), (intptr_t) (2) } },
    { "vertexAttribPointer", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointer), (intptr_t) (6) } },
    { "viewport", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsWebGLRenderingContextBasePrototypeFunctionViewport), (intptr_t) (4) } },
    { "DEPTH_BUFFER_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00000100) } },
    { "STENCIL_BUFFER_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00000400) } },
    { "COLOR_BUFFER_BIT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x00004000) } },
    { "POINTS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0000) } },
    { "LINES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0001) } },
    { "LINE_LOOP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0002) } },
    { "LINE_STRIP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0003) } },
    { "TRIANGLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0004) } },
    { "TRIANGLE_STRIP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0005) } },
    { "TRIANGLE_FAN", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0006) } },
    { "ZERO", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "ONE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
    { "SRC_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0300) } },
    { "ONE_MINUS_SRC_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0301) } },
    { "SRC_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0302) } },
    { "ONE_MINUS_SRC_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0303) } },
    { "DST_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0304) } },
    { "ONE_MINUS_DST_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0305) } },
    { "DST_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0306) } },
    { "ONE_MINUS_DST_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0307) } },
    { "SRC_ALPHA_SATURATE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0308) } },
    { "FUNC_ADD", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8006) } },
    { "BLEND_EQUATION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8009) } },
    { "BLEND_EQUATION_RGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8009) } },
    { "BLEND_EQUATION_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x883D) } },
    { "FUNC_SUBTRACT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x800A) } },
    { "FUNC_REVERSE_SUBTRACT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x800B) } },
    { "BLEND_DST_RGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80C8) } },
    { "BLEND_SRC_RGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80C9) } },
    { "BLEND_DST_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80CA) } },
    { "BLEND_SRC_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80CB) } },
    { "CONSTANT_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8001) } },
    { "ONE_MINUS_CONSTANT_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8002) } },
    { "CONSTANT_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8003) } },
    { "ONE_MINUS_CONSTANT_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8004) } },
    { "BLEND_COLOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8005) } },
    { "ARRAY_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8892) } },
    { "ELEMENT_ARRAY_BUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8893) } },
    { "ARRAY_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8894) } },
    { "ELEMENT_ARRAY_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8895) } },
    { "STREAM_DRAW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E0) } },
    { "STATIC_DRAW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E4) } },
    { "DYNAMIC_DRAW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x88E8) } },
    { "BUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8764) } },
    { "BUFFER_USAGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8765) } },
    { "CURRENT_VERTEX_ATTRIB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8626) } },
    { "FRONT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0404) } },
    { "BACK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0405) } },
    { "FRONT_AND_BACK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0408) } },
    { "TEXTURE_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0DE1) } },
    { "CULL_FACE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B44) } },
    { "BLEND", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0BE2) } },
    { "DITHER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0BD0) } },
    { "STENCIL_TEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B90) } },
    { "DEPTH_TEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B71) } },
    { "SCISSOR_TEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C11) } },
    { "POLYGON_OFFSET_FILL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8037) } },
    { "SAMPLE_ALPHA_TO_COVERAGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x809E) } },
    { "SAMPLE_COVERAGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80A0) } },
    { "NO_ERROR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "INVALID_ENUM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0500) } },
    { "INVALID_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0501) } },
    { "INVALID_OPERATION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0502) } },
    { "OUT_OF_MEMORY", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0505) } },
    { "CW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0900) } },
    { "CCW", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0901) } },
    { "LINE_WIDTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B21) } },
    { "ALIASED_POINT_SIZE_RANGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x846D) } },
    { "ALIASED_LINE_WIDTH_RANGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x846E) } },
    { "CULL_FACE_MODE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B45) } },
    { "FRONT_FACE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B46) } },
    { "DEPTH_RANGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B70) } },
    { "DEPTH_WRITEMASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B72) } },
    { "DEPTH_CLEAR_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B73) } },
    { "DEPTH_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B74) } },
    { "STENCIL_CLEAR_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B91) } },
    { "STENCIL_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B92) } },
    { "STENCIL_FAIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B94) } },
    { "STENCIL_PASS_DEPTH_FAIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B95) } },
    { "STENCIL_PASS_DEPTH_PASS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B96) } },
    { "STENCIL_REF", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B97) } },
    { "STENCIL_VALUE_MASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B93) } },
    { "STENCIL_WRITEMASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0B98) } },
    { "STENCIL_BACK_FUNC", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8800) } },
    { "STENCIL_BACK_FAIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8801) } },
    { "STENCIL_BACK_PASS_DEPTH_FAIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8802) } },
    { "STENCIL_BACK_PASS_DEPTH_PASS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8803) } },
    { "STENCIL_BACK_REF", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA3) } },
    { "STENCIL_BACK_VALUE_MASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA4) } },
    { "STENCIL_BACK_WRITEMASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA5) } },
    { "VIEWPORT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0BA2) } },
    { "SCISSOR_BOX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C10) } },
    { "COLOR_CLEAR_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C22) } },
    { "COLOR_WRITEMASK", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0C23) } },
    { "UNPACK_ALIGNMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0CF5) } },
    { "PACK_ALIGNMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D05) } },
    { "MAX_TEXTURE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D33) } },
    { "MAX_VIEWPORT_DIMS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D3A) } },
    { "SUBPIXEL_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D50) } },
    { "RED_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D52) } },
    { "GREEN_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D53) } },
    { "BLUE_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D54) } },
    { "ALPHA_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D55) } },
    { "DEPTH_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D56) } },
    { "STENCIL_BITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0D57) } },
    { "POLYGON_OFFSET_UNITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2A00) } },
    { "POLYGON_OFFSET_FACTOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8038) } },
    { "TEXTURE_BINDING_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8069) } },
    { "SAMPLE_BUFFERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80A8) } },
    { "SAMPLES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80A9) } },
    { "SAMPLE_COVERAGE_VALUE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80AA) } },
    { "SAMPLE_COVERAGE_INVERT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x80AB) } },
    { "COMPRESSED_TEXTURE_FORMATS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x86A3) } },
    { "DONT_CARE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1100) } },
    { "FASTEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1101) } },
    { "NICEST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1102) } },
    { "GENERATE_MIPMAP_HINT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8192) } },
    { "BYTE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1400) } },
    { "UNSIGNED_BYTE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1401) } },
    { "SHORT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1402) } },
    { "UNSIGNED_SHORT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1403) } },
    { "INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1404) } },
    { "UNSIGNED_INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1405) } },
    { "FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1406) } },
    { "DEPTH_COMPONENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1902) } },
    { "ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1906) } },
    { "RGB", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1907) } },
    { "RGBA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1908) } },
    { "LUMINANCE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1909) } },
    { "LUMINANCE_ALPHA", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x190A) } },
    { "UNSIGNED_SHORT_4_4_4_4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8033) } },
    { "UNSIGNED_SHORT_5_5_5_1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8034) } },
    { "UNSIGNED_SHORT_5_6_5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8363) } },
    { "FRAGMENT_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B30) } },
    { "VERTEX_SHADER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B31) } },
    { "MAX_VERTEX_ATTRIBS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8869) } },
    { "MAX_VERTEX_UNIFORM_VECTORS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DFB) } },
    { "MAX_VARYING_VECTORS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DFC) } },
    { "MAX_COMBINED_TEXTURE_IMAGE_UNITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4D) } },
    { "MAX_VERTEX_TEXTURE_IMAGE_UNITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4C) } },
    { "MAX_TEXTURE_IMAGE_UNITS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8872) } },
    { "MAX_FRAGMENT_UNIFORM_VECTORS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DFD) } },
    { "SHADER_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B4F) } },
    { "DELETE_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B80) } },
    { "LINK_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B82) } },
    { "VALIDATE_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B83) } },
    { "ATTACHED_SHADERS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B85) } },
    { "ACTIVE_UNIFORMS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B86) } },
    { "ACTIVE_ATTRIBUTES", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B89) } },
    { "SHADING_LANGUAGE_VERSION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B8C) } },
    { "CURRENT_PROGRAM", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B8D) } },
    { "NEVER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0200) } },
    { "LESS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0201) } },
    { "EQUAL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0202) } },
    { "LEQUAL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0203) } },
    { "GREATER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0204) } },
    { "NOTEQUAL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0205) } },
    { "GEQUAL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0206) } },
    { "ALWAYS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0207) } },
    { "KEEP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1E00) } },
    { "REPLACE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1E01) } },
    { "INCR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1E02) } },
    { "DECR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1E03) } },
    { "INVERT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x150A) } },
    { "INCR_WRAP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8507) } },
    { "DECR_WRAP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8508) } },
    { "VENDOR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1F00) } },
    { "RENDERER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1F01) } },
    { "VERSION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1F02) } },
    { "NEAREST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2600) } },
    { "LINEAR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2601) } },
    { "NEAREST_MIPMAP_NEAREST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2700) } },
    { "LINEAR_MIPMAP_NEAREST", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2701) } },
    { "NEAREST_MIPMAP_LINEAR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2702) } },
    { "LINEAR_MIPMAP_LINEAR", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2703) } },
    { "TEXTURE_MAG_FILTER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2800) } },
    { "TEXTURE_MIN_FILTER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2801) } },
    { "TEXTURE_WRAP_S", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2802) } },
    { "TEXTURE_WRAP_T", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2803) } },
    { "TEXTURE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1702) } },
    { "TEXTURE_CUBE_MAP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8513) } },
    { "TEXTURE_BINDING_CUBE_MAP", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8514) } },
    { "TEXTURE_CUBE_MAP_POSITIVE_X", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8515) } },
    { "TEXTURE_CUBE_MAP_NEGATIVE_X", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8516) } },
    { "TEXTURE_CUBE_MAP_POSITIVE_Y", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8517) } },
    { "TEXTURE_CUBE_MAP_NEGATIVE_Y", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8518) } },
    { "TEXTURE_CUBE_MAP_POSITIVE_Z", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8519) } },
    { "TEXTURE_CUBE_MAP_NEGATIVE_Z", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x851A) } },
    { "MAX_CUBE_MAP_TEXTURE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x851C) } },
    { "TEXTURE0", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C0) } },
    { "TEXTURE1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C1) } },
    { "TEXTURE2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C2) } },
    { "TEXTURE3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C3) } },
    { "TEXTURE4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C4) } },
    { "TEXTURE5", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C5) } },
    { "TEXTURE6", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C6) } },
    { "TEXTURE7", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C7) } },
    { "TEXTURE8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C8) } },
    { "TEXTURE9", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84C9) } },
    { "TEXTURE10", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CA) } },
    { "TEXTURE11", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CB) } },
    { "TEXTURE12", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CC) } },
    { "TEXTURE13", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CD) } },
    { "TEXTURE14", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CE) } },
    { "TEXTURE15", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84CF) } },
    { "TEXTURE16", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D0) } },
    { "TEXTURE17", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D1) } },
    { "TEXTURE18", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D2) } },
    { "TEXTURE19", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D3) } },
    { "TEXTURE20", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D4) } },
    { "TEXTURE21", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D5) } },
    { "TEXTURE22", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D6) } },
    { "TEXTURE23", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D7) } },
    { "TEXTURE24", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D8) } },
    { "TEXTURE25", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84D9) } },
    { "TEXTURE26", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DA) } },
    { "TEXTURE27", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DB) } },
    { "TEXTURE28", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DC) } },
    { "TEXTURE29", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DD) } },
    { "TEXTURE30", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DE) } },
    { "TEXTURE31", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84DF) } },
    { "ACTIVE_TEXTURE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84E0) } },
    { "REPEAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x2901) } },
    { "CLAMP_TO_EDGE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x812F) } },
    { "MIRRORED_REPEAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8370) } },
    { "FLOAT_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B50) } },
    { "FLOAT_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B51) } },
    { "FLOAT_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B52) } },
    { "INT_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B53) } },
    { "INT_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B54) } },
    { "INT_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B55) } },
    { "BOOL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B56) } },
    { "BOOL_VEC2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B57) } },
    { "BOOL_VEC3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B58) } },
    { "BOOL_VEC4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B59) } },
    { "FLOAT_MAT2", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5A) } },
    { "FLOAT_MAT3", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5B) } },
    { "FLOAT_MAT4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5C) } },
    { "SAMPLER_2D", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B5E) } },
    { "SAMPLER_CUBE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B60) } },
    { "VERTEX_ATTRIB_ARRAY_ENABLED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8622) } },
    { "VERTEX_ATTRIB_ARRAY_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8623) } },
    { "VERTEX_ATTRIB_ARRAY_STRIDE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8624) } },
    { "VERTEX_ATTRIB_ARRAY_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8625) } },
    { "VERTEX_ATTRIB_ARRAY_NORMALIZED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x886A) } },
    { "VERTEX_ATTRIB_ARRAY_POINTER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8645) } },
    { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x889F) } },
    { "IMPLEMENTATION_COLOR_READ_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B9A) } },
    { "IMPLEMENTATION_COLOR_READ_FORMAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B9B) } },
    { "COMPILE_STATUS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8B81) } },
    { "LOW_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF0) } },
    { "MEDIUM_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF1) } },
    { "HIGH_FLOAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF2) } },
    { "LOW_INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF3) } },
    { "MEDIUM_INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF4) } },
    { "HIGH_INT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8DF5) } },
    { "FRAMEBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D40) } },
    { "RENDERBUFFER", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D41) } },
    { "RGBA4", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8056) } },
    { "RGB5_A1", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8057) } },
    { "RGB565", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D62) } },
    { "DEPTH_COMPONENT16", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x81A5) } },
    { "STENCIL_INDEX", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x1901) } },
    { "STENCIL_INDEX8", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D48) } },
    { "DEPTH_STENCIL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84F9) } },
    { "RENDERBUFFER_WIDTH", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D42) } },
    { "RENDERBUFFER_HEIGHT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D43) } },
    { "RENDERBUFFER_INTERNAL_FORMAT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D44) } },
    { "RENDERBUFFER_RED_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D50) } },
    { "RENDERBUFFER_GREEN_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D51) } },
    { "RENDERBUFFER_BLUE_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D52) } },
    { "RENDERBUFFER_ALPHA_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D53) } },
    { "RENDERBUFFER_DEPTH_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D54) } },
    { "RENDERBUFFER_STENCIL_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D55) } },
    { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD0) } },
    { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD1) } },
    { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD2) } },
    { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD3) } },
    { "COLOR_ATTACHMENT0", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CE0) } },
    { "DEPTH_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D00) } },
    { "STENCIL_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8D20) } },
    { "DEPTH_STENCIL_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x821A) } },
    { "NONE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0) } },
    { "FRAMEBUFFER_COMPLETE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD5) } },
    { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD6) } },
    { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD7) } },
    { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CD9) } },
    { "FRAMEBUFFER_UNSUPPORTED", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CDD) } },
    { "FRAMEBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA6) } },
    { "RENDERBUFFER_BINDING", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x8CA7) } },
    { "MAX_RENDERBUFFER_SIZE", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x84E8) } },
    { "INVALID_FRAMEBUFFER_OPERATION", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x0506) } },
    { "UNPACK_FLIP_Y_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9240) } },
    { "UNPACK_PREMULTIPLY_ALPHA_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9241) } },
    { "CONTEXT_LOST_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9242) } },
    { "UNPACK_COLORSPACE_CONVERSION_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9243) } },
    { "BROWSER_DEFAULT_WEBGL", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(0x9244) } },
};

const ClassInfo JSWebGLRenderingContextBasePrototype::s_info = { "WebGLRenderingContextBasePrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGLRenderingContextBasePrototype) };

void JSWebGLRenderingContextBasePrototype::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    reifyStaticProperties(vm, JSWebGLRenderingContextBasePrototypeTableValues, *this);
}

const ClassInfo JSWebGLRenderingContextBase::s_info = { "WebGLRenderingContextBase", &Base::s_info, 0, CREATE_METHOD_TABLE(JSWebGLRenderingContextBase) };

JSWebGLRenderingContextBase::JSWebGLRenderingContextBase(Structure* structure, JSDOMGlobalObject& globalObject, Ref<WebGLRenderingContextBase>&& impl)
    : JSCanvasRenderingContext(structure, globalObject, WTFMove(impl))
{
}

JSObject* JSWebGLRenderingContextBase::createPrototype(VM& vm, JSGlobalObject* globalObject)
{
    return JSWebGLRenderingContextBasePrototype::create(vm, globalObject, JSWebGLRenderingContextBasePrototype::createStructure(vm, globalObject, JSCanvasRenderingContext::prototype(vm, globalObject)));
}

JSObject* JSWebGLRenderingContextBase::prototype(VM& vm, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSWebGLRenderingContextBase>(vm, globalObject);
}

EncodedJSValue jsWebGLRenderingContextBaseDrawingBufferWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "WebGLRenderingContextBase", "drawingBufferWidth");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.drawingBufferWidth());
    return JSValue::encode(result);
}


EncodedJSValue jsWebGLRenderingContextBaseDrawingBufferHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
{
    UNUSED_PARAM(state);
    UNUSED_PARAM(thisValue);
    JSValue decodedThisValue = JSValue::decode(thisValue);
    auto* castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(decodedThisValue);
    if (UNLIKELY(!castedThis)) {
        return throwGetterTypeError(*state, "WebGLRenderingContextBase", "drawingBufferHeight");
    }
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.drawingBufferHeight());
    return JSValue::encode(result);
}


bool setJSWebGLRenderingContextBaseConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
{
    JSValue value = JSValue::decode(encodedValue);
    JSWebGLRenderingContextBasePrototype* domObject = jsDynamicCast<JSWebGLRenderingContextBasePrototype*>(JSValue::decode(thisValue));
    if (UNLIKELY(!domObject)) {
        throwVMTypeError(state);
        return false;
    }
    // Shadowing a built-in constructor
    return domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionActiveTexture(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "activeTexture");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto texture = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.activeTexture(WTFMove(texture), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionAttachShader(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "attachShader");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "attachShader", "WebGLProgram");
    }
    WebGLShader* shader = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        shader = JSWebGLShader::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!shader))
            return throwArgumentTypeError(*state, 1, "shader", "WebGLRenderingContextBase", "attachShader", "WebGLShader");
    }
    impl.attachShader(program, shader, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindAttribLocation(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bindAttribLocation");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "bindAttribLocation", "WebGLProgram");
    }
    auto index = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto name = state->argument(2).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bindAttribLocation(program, WTFMove(index), WTFMove(name), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindBuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bindBuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLBuffer* buffer = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        buffer = JSWebGLBuffer::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!buffer))
            return throwArgumentTypeError(*state, 1, "buffer", "WebGLRenderingContextBase", "bindBuffer", "WebGLBuffer");
    }
    impl.bindBuffer(WTFMove(target), buffer, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindFramebuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bindFramebuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLFramebuffer* framebuffer = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        framebuffer = JSWebGLFramebuffer::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!framebuffer))
            return throwArgumentTypeError(*state, 1, "framebuffer", "WebGLRenderingContextBase", "bindFramebuffer", "WebGLFramebuffer");
    }
    impl.bindFramebuffer(WTFMove(target), framebuffer, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindRenderbuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bindRenderbuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLRenderbuffer* renderbuffer = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        renderbuffer = JSWebGLRenderbuffer::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!renderbuffer))
            return throwArgumentTypeError(*state, 1, "renderbuffer", "WebGLRenderingContextBase", "bindRenderbuffer", "WebGLRenderbuffer");
    }
    impl.bindRenderbuffer(WTFMove(target), renderbuffer, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBindTexture(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bindTexture");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLTexture* texture = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        texture = JSWebGLTexture::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!texture))
            return throwArgumentTypeError(*state, 1, "texture", "WebGLRenderingContextBase", "bindTexture", "WebGLTexture");
    }
    impl.bindTexture(WTFMove(target), texture, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendColor(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "blendColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto red = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto green = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto blue = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.blendColor(WTFMove(red), WTFMove(green), WTFMove(blue), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendEquation(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "blendEquation");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto mode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.blendEquation(WTFMove(mode));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendEquationSeparate(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "blendEquationSeparate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto modeRGB = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto modeAlpha = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.blendEquationSeparate(WTFMove(modeRGB), WTFMove(modeAlpha));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendFunc(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "blendFunc");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto sfactor = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dfactor = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.blendFunc(WTFMove(sfactor), WTFMove(dfactor));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBlendFuncSeparate(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "blendFuncSeparate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto srcRGB = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dstRGB = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto srcAlpha = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto dstAlpha = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.blendFuncSeparate(WTFMove(srcRGB), WTFMove(dstRGB), WTFMove(srcAlpha), WTFMove(dstAlpha));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bufferData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto data = toArrayBuffer(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    if (UNLIKELY(!data))
        return throwArgumentTypeError(*state, 1, "data", "WebGLRenderingContextBase", "bufferData", "ArrayBuffer");
    auto usage = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bufferData(WTFMove(target), *data, WTFMove(usage), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bufferData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto data = toArrayBufferView(state->argument(1));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    if (UNLIKELY(!data))
        return throwArgumentTypeError(*state, 1, "data", "WebGLRenderingContextBase", "bufferData", "ArrayBufferView");
    auto usage = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bufferData(WTFMove(target), data.releaseNonNull(), WTFMove(usage), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferData3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bufferData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto size = convert<int64_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto usage = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bufferData(WTFMove(target), WTFMove(size), WTFMove(usage), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBufferData(ExecState* state)
{
    size_t argsCount = std::min<size_t>(3, state->argumentCount());
    JSValue arg1(state->argument(1));
    if ((argsCount == 3 && ((arg1.isObject() && asObject(arg1)->inherits(JSArrayBuffer::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionBufferData1(state);
    if ((argsCount == 3 && ((arg1.isObject() && asObject(arg1)->inherits(JSArrayBufferView::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionBufferData2(state);
    if (argsCount == 3)
        return jsWebGLRenderingContextBasePrototypeFunctionBufferData3(state);
    if (UNLIKELY(argsCount < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    return throwVMTypeError(state);
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferSubData1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bufferSubData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto offset = convert<int64_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto data = toArrayBuffer(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bufferSubData(WTFMove(target), WTFMove(offset), WTFMove(data), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionBufferSubData2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "bufferSubData");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto offset = convert<int64_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto data = toArrayBufferView(state->argument(2));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.bufferSubData(WTFMove(target), WTFMove(offset), WTFMove(data), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionBufferSubData(ExecState* state)
{
    size_t argsCount = std::min<size_t>(3, state->argumentCount());
    JSValue arg2(state->argument(2));
    if ((argsCount == 3 && (arg2.isUndefinedOrNull() || (arg2.isObject() && asObject(arg2)->inherits(JSArrayBuffer::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionBufferSubData1(state);
    if ((argsCount == 3 && (arg2.isUndefinedOrNull() || (arg2.isObject() && asObject(arg2)->inherits(JSArrayBufferView::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionBufferSubData2(state);
    if (UNLIKELY(argsCount < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    return throwVMTypeError(state);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCheckFramebufferStatus(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "checkFramebufferStatus");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsNumber(impl.checkFramebufferStatus(WTFMove(target)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClear(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "clear");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto mask = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clear(WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearColor(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "clearColor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto red = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto green = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto blue = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearColor(WTFMove(red), WTFMove(green), WTFMove(blue), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearDepth(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "clearDepth");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto depth = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearDepth(WTFMove(depth));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionClearStencil(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "clearStencil");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto s = convert<int32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.clearStencil(WTFMove(s));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionColorMask(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "colorMask");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto red = state->argument(0).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto green = state->argument(1).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto blue = state->argument(2).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto alpha = state->argument(3).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.colorMask(WTFMove(red), WTFMove(green), WTFMove(blue), WTFMove(alpha));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompileShader(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "compileShader");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLShader* shader = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        shader = JSWebGLShader::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!shader))
            return throwArgumentTypeError(*state, 0, "shader", "WebGLRenderingContextBase", "compileShader", "WebGLShader");
    }
    impl.compileShader(shader, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompressedTexImage2D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "compressedTexImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto border = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto data = toArrayBufferView(state->argument(6));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    if (UNLIKELY(!data))
        return throwArgumentTypeError(*state, 6, "data", "WebGLRenderingContextBase", "compressedTexImage2D", "ArrayBufferView");
    impl.compressedTexImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(border), data.releaseNonNull());
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCompressedTexSubImage2D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "compressedTexSubImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto data = toArrayBufferView(state->argument(7));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    if (UNLIKELY(!data))
        return throwArgumentTypeError(*state, 7, "data", "WebGLRenderingContextBase", "compressedTexSubImage2D", "ArrayBufferView");
    impl.compressedTexSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(width), WTFMove(height), WTFMove(format), data.releaseNonNull());
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCopyTexImage2D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "copyTexImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto border = convert<int32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.copyTexImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height), WTFMove(border));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCopyTexSubImage2D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "copyTexSubImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 8))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.copyTexSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateBuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "createBuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createBuffer());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateFramebuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "createFramebuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createFramebuffer());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateProgram(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "createProgram");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createProgram());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateRenderbuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "createRenderbuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createRenderbuffer());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateShader(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "createShader");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto type = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.createShader(WTFMove(type), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCreateTexture(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "createTexture");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.createTexture());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionCullFace(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "cullFace");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto mode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.cullFace(WTFMove(mode));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteBuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "deleteBuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLBuffer* buffer = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        buffer = JSWebGLBuffer::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!buffer))
            return throwArgumentTypeError(*state, 0, "buffer", "WebGLRenderingContextBase", "deleteBuffer", "WebGLBuffer");
    }
    impl.deleteBuffer(buffer);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteFramebuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "deleteFramebuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLFramebuffer* framebuffer = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        framebuffer = JSWebGLFramebuffer::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!framebuffer))
            return throwArgumentTypeError(*state, 0, "framebuffer", "WebGLRenderingContextBase", "deleteFramebuffer", "WebGLFramebuffer");
    }
    impl.deleteFramebuffer(framebuffer);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteProgram(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "deleteProgram");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "deleteProgram", "WebGLProgram");
    }
    impl.deleteProgram(program);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteRenderbuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "deleteRenderbuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLRenderbuffer* renderbuffer = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        renderbuffer = JSWebGLRenderbuffer::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!renderbuffer))
            return throwArgumentTypeError(*state, 0, "renderbuffer", "WebGLRenderingContextBase", "deleteRenderbuffer", "WebGLRenderbuffer");
    }
    impl.deleteRenderbuffer(renderbuffer);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteShader(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "deleteShader");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLShader* shader = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        shader = JSWebGLShader::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!shader))
            return throwArgumentTypeError(*state, 0, "shader", "WebGLRenderingContextBase", "deleteShader", "WebGLShader");
    }
    impl.deleteShader(shader);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDeleteTexture(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "deleteTexture");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLTexture* texture = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        texture = JSWebGLTexture::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!texture))
            return throwArgumentTypeError(*state, 0, "texture", "WebGLRenderingContextBase", "deleteTexture", "WebGLTexture");
    }
    impl.deleteTexture(texture);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthFunc(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "depthFunc");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto func = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.depthFunc(WTFMove(func));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthMask(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "depthMask");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto flag = state->argument(0).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.depthMask(WTFMove(flag));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDepthRange(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "depthRange");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto zNear = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zFar = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.depthRange(WTFMove(zNear), WTFMove(zFar));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDetachShader(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "detachShader");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "detachShader", "WebGLProgram");
    }
    WebGLShader* shader = nullptr;
    if (!state->argument(1).isUndefinedOrNull()) {
        shader = JSWebGLShader::toWrapped(state->uncheckedArgument(1));
        if (UNLIKELY(!shader))
            return throwArgumentTypeError(*state, 1, "shader", "WebGLRenderingContextBase", "detachShader", "WebGLShader");
    }
    impl.detachShader(program, shader, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDisable(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "disable");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto cap = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.disable(WTFMove(cap));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDisableVertexAttribArray(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "disableVertexAttribArray");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.disableVertexAttribArray(WTFMove(index), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDrawArrays(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "drawArrays");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto mode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto first = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto count = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawArrays(WTFMove(mode), WTFMove(first), WTFMove(count), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionDrawElements(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "drawElements");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto mode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto count = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto offset = convert<int64_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.drawElements(WTFMove(mode), WTFMove(count), WTFMove(type), WTFMove(offset), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionEnable(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "enable");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto cap = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.enable(WTFMove(cap));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionEnableVertexAttribArray(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "enableVertexAttribArray");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.enableVertexAttribArray(WTFMove(index), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFinish(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "finish");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    impl.finish();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFlush(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "flush");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    impl.flush();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFramebufferRenderbuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "framebufferRenderbuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto attachment = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto renderbuffertarget = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLRenderbuffer* renderbuffer = nullptr;
    if (!state->argument(3).isUndefinedOrNull()) {
        renderbuffer = JSWebGLRenderbuffer::toWrapped(state->uncheckedArgument(3));
        if (UNLIKELY(!renderbuffer))
            return throwArgumentTypeError(*state, 3, "renderbuffer", "WebGLRenderingContextBase", "framebufferRenderbuffer", "WebGLRenderbuffer");
    }
    impl.framebufferRenderbuffer(WTFMove(target), WTFMove(attachment), WTFMove(renderbuffertarget), renderbuffer, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFramebufferTexture2D(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "framebufferTexture2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto attachment = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto textarget = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    WebGLTexture* texture = nullptr;
    if (!state->argument(3).isUndefinedOrNull()) {
        texture = JSWebGLTexture::toWrapped(state->uncheckedArgument(3));
        if (UNLIKELY(!texture))
            return throwArgumentTypeError(*state, 3, "texture", "WebGLRenderingContextBase", "framebufferTexture2D", "WebGLTexture");
    }
    auto level = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.framebufferTexture2D(WTFMove(target), WTFMove(attachment), WTFMove(textarget), texture, WTFMove(level), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionFrontFace(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "frontFace");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto mode = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.frontFace(WTFMove(mode));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGenerateMipmap(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "generateMipmap");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.generateMipmap(WTFMove(target));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetActiveAttrib(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getActiveAttrib");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "getActiveAttrib", "WebGLProgram");
    }
    auto index = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getActiveAttrib(program, WTFMove(index), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetActiveUniform(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getActiveUniform");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "getActiveUniform", "WebGLProgram");
    }
    auto index = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getActiveUniform(program, WTFMove(index), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetAttachedShaders(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getAttachedShaders");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getAttachedShaders(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetAttribLocation(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getAttribLocation");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "getAttribLocation", "WebGLProgram");
    }
    auto name = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsNumber(impl.getAttribLocation(program, WTFMove(name)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetBufferParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getBufferParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getBufferParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetContextAttributes(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getContextAttributes");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    JSValue result = toJS(state, castedThis->globalObject(), impl.getContextAttributes());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetError(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getError");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    JSValue result = jsNumber(impl.getError());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetExtension(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getExtension");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getExtension(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetFramebufferAttachmentParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getFramebufferAttachmentParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getFramebufferAttachmentParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetProgramParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getProgramParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getProgramParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetProgramInfoLog(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getProgramInfoLog");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "getProgramInfoLog", "WebGLProgram");
    }
    JSValue result = jsStringOrNull(state, impl.getProgramInfoLog(program, ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetRenderbufferParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getRenderbufferParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getRenderbufferParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getShaderParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getShaderParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderInfoLog(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getShaderInfoLog");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLShader* shader = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        shader = JSWebGLShader::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!shader))
            return throwArgumentTypeError(*state, 0, "shader", "WebGLRenderingContextBase", "getShaderInfoLog", "WebGLShader");
    }
    JSValue result = jsStringOrNull(state, impl.getShaderInfoLog(shader, ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderPrecisionFormat(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getShaderPrecisionFormat");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto shadertype = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto precisiontype = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getShaderPrecisionFormat(WTFMove(shadertype), WTFMove(precisiontype), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetShaderSource(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getShaderSource");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLShader* shader = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        shader = JSWebGLShader::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!shader))
            return throwArgumentTypeError(*state, 0, "shader", "WebGLRenderingContextBase", "getShaderSource", "WebGLShader");
    }
    JSValue result = jsStringOrNull(state, impl.getShaderSource(shader, ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetSupportedExtensions(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getSupportedExtensions");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getSupportedExtensions(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetTexParameter(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getTexParameter");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getTexParameter(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetUniform(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getUniform");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getUniform(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetUniformLocation(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getUniformLocation");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "getUniformLocation", "WebGLProgram");
    }
    auto name = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = toJS(state, castedThis->globalObject(), impl.getUniformLocation(program, WTFMove(name), ec));

    setDOMException(state, ec);
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttrib(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getVertexAttrib");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->getVertexAttrib(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionGetVertexAttribOffset(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "getVertexAttribOffset");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto index = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pname = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsNumber(impl.getVertexAttribOffset(WTFMove(index), WTFMove(pname)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionHint(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "hint");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto mode = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.hint(WTFMove(target), WTFMove(mode));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsBuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "isBuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLBuffer* buffer = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        buffer = JSWebGLBuffer::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!buffer))
            return throwArgumentTypeError(*state, 0, "buffer", "WebGLRenderingContextBase", "isBuffer", "WebGLBuffer");
    }
    JSValue result = jsBoolean(impl.isBuffer(buffer));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsContextLost(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "isContextLost");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    JSValue result = jsBoolean(impl.isContextLost());
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsEnabled(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "isEnabled");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto cap = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    JSValue result = jsBoolean(impl.isEnabled(WTFMove(cap)));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsFramebuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "isFramebuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLFramebuffer* framebuffer = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        framebuffer = JSWebGLFramebuffer::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!framebuffer))
            return throwArgumentTypeError(*state, 0, "framebuffer", "WebGLRenderingContextBase", "isFramebuffer", "WebGLFramebuffer");
    }
    JSValue result = jsBoolean(impl.isFramebuffer(framebuffer));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsProgram(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "isProgram");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "isProgram", "WebGLProgram");
    }
    JSValue result = jsBoolean(impl.isProgram(program));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsRenderbuffer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "isRenderbuffer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLRenderbuffer* renderbuffer = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        renderbuffer = JSWebGLRenderbuffer::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!renderbuffer))
            return throwArgumentTypeError(*state, 0, "renderbuffer", "WebGLRenderingContextBase", "isRenderbuffer", "WebGLRenderbuffer");
    }
    JSValue result = jsBoolean(impl.isRenderbuffer(renderbuffer));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsShader(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "isShader");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLShader* shader = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        shader = JSWebGLShader::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!shader))
            return throwArgumentTypeError(*state, 0, "shader", "WebGLRenderingContextBase", "isShader", "WebGLShader");
    }
    JSValue result = jsBoolean(impl.isShader(shader));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionIsTexture(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "isTexture");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    WebGLTexture* texture = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        texture = JSWebGLTexture::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!texture))
            return throwArgumentTypeError(*state, 0, "texture", "WebGLRenderingContextBase", "isTexture", "WebGLTexture");
    }
    JSValue result = jsBoolean(impl.isTexture(texture));
    return JSValue::encode(result);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionLineWidth(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "lineWidth");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto width = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.lineWidth(WTFMove(width));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionLinkProgram(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "linkProgram");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "linkProgram", "WebGLProgram");
    }
    impl.linkProgram(program, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionPixelStorei(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "pixelStorei");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto pname = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto param = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.pixelStorei(WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionPolygonOffset(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "polygonOffset");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto factor = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto units = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.polygonOffset(WTFMove(factor), WTFMove(units));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionReadPixels(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "readPixels");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto x = convert<int32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pixels = toArrayBufferView(state->argument(6));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    if (UNLIKELY(!pixels))
        return throwArgumentTypeError(*state, 6, "pixels", "WebGLRenderingContextBase", "readPixels", "ArrayBufferView");
    impl.readPixels(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height), WTFMove(format), WTFMove(type), pixels.releaseNonNull(), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionReleaseShaderCompiler(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "releaseShaderCompiler");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    impl.releaseShaderCompiler();
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionRenderbufferStorage(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "renderbufferStorage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.renderbufferStorage(WTFMove(target), WTFMove(internalformat), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionSampleCoverage(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "sampleCoverage");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto value = convert<float>(*state, state->argument(0), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto invert = state->argument(1).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.sampleCoverage(WTFMove(value), WTFMove(invert));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionScissor(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "scissor");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<int32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.scissor(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionShaderSource(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "shaderSource");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLShader* shader = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        shader = JSWebGLShader::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!shader))
            return throwArgumentTypeError(*state, 0, "shader", "WebGLRenderingContextBase", "shaderSource", "WebGLShader");
    }
    auto string = state->argument(1).toWTFString(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.shaderSource(shader, WTFMove(string), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilFunc(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "stencilFunc");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto func = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto ref = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto mask = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.stencilFunc(WTFMove(func), WTFMove(ref), WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilFuncSeparate(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "stencilFuncSeparate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto face = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto func = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto ref = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto mask = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.stencilFuncSeparate(WTFMove(face), WTFMove(func), WTFMove(ref), WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilMask(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "stencilMask");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto mask = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.stencilMask(WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilMaskSeparate(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "stencilMaskSeparate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto face = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto mask = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.stencilMaskSeparate(WTFMove(face), WTFMove(mask));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilOp(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "stencilOp");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto fail = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zfail = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zpass = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.stencilOp(WTFMove(fail), WTFMove(zfail), WTFMove(zpass));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionStencilOpSeparate(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "stencilOpSeparate");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto face = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto fail = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zfail = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto zpass = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.stencilOpSeparate(WTFMove(face), WTFMove(fail), WTFMove(zfail), WTFMove(zpass));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexParameterf(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texParameterf");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pname = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto param = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.texParameterf(WTFMove(target), WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexParameteri(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texParameteri");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pname = convert<uint32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto param = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.texParameteri(WTFMove(target), WTFMove(pname), WTFMove(param));
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto border = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pixels = toArrayBufferView(state->argument(8));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.texImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(width), WTFMove(height), WTFMove(border), WTFMove(format), WTFMove(type), WTFMove(pixels), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    ImageData* pixels = nullptr;
    if (!state->argument(5).isUndefinedOrNull()) {
        pixels = JSImageData::toWrapped(state->uncheckedArgument(5));
        if (UNLIKELY(!pixels))
            return throwArgumentTypeError(*state, 5, "pixels", "WebGLRenderingContextBase", "texImage2D", "ImageData");
    }
    impl.texImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(format), WTFMove(type), pixels, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLImageElement* image = nullptr;
    if (!state->argument(5).isUndefinedOrNull()) {
        image = JSHTMLImageElement::toWrapped(state->uncheckedArgument(5));
        if (UNLIKELY(!image))
            return throwArgumentTypeError(*state, 5, "image", "WebGLRenderingContextBase", "texImage2D", "HTMLImageElement");
    }
    impl.texImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(format), WTFMove(type), image, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D4(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLCanvasElement* canvas = nullptr;
    if (!state->argument(5).isUndefinedOrNull()) {
        canvas = JSHTMLCanvasElement::toWrapped(state->uncheckedArgument(5));
        if (UNLIKELY(!canvas))
            return throwArgumentTypeError(*state, 5, "canvas", "WebGLRenderingContextBase", "texImage2D", "HTMLCanvasElement");
    }
    impl.texImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(format), WTFMove(type), canvas, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexImage2D5(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto internalformat = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLVideoElement* video = nullptr;
    if (!state->argument(5).isUndefinedOrNull()) {
        video = JSHTMLVideoElement::toWrapped(state->uncheckedArgument(5));
        if (UNLIKELY(!video))
            return throwArgumentTypeError(*state, 5, "video", "WebGLRenderingContextBase", "texImage2D", "HTMLVideoElement");
    }
    impl.texImage2D(WTFMove(target), WTFMove(level), WTFMove(internalformat), WTFMove(format), WTFMove(type), video, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexImage2D(ExecState* state)
{
    size_t argsCount = std::min<size_t>(9, state->argumentCount());
    JSValue arg8(state->argument(8));
    if ((argsCount == 9 && (arg8.isUndefinedOrNull() || (arg8.isObject() && asObject(arg8)->inherits(JSArrayBufferView::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexImage2D1(state);
    JSValue arg5(state->argument(5));
    if ((argsCount == 6 && (arg5.isUndefinedOrNull() || (arg5.isObject() && asObject(arg5)->inherits(JSImageData::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexImage2D2(state);
    if ((argsCount == 6 && (arg5.isUndefinedOrNull() || (arg5.isObject() && asObject(arg5)->inherits(JSHTMLImageElement::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexImage2D3(state);
    if ((argsCount == 6 && (arg5.isUndefinedOrNull() || (arg5.isObject() && asObject(arg5)->inherits(JSHTMLCanvasElement::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexImage2D4(state);
    if ((argsCount == 6 && (arg5.isUndefinedOrNull() || (arg5.isObject() && asObject(arg5)->inherits(JSHTMLVideoElement::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexImage2D5(state);
    if (UNLIKELY(argsCount < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    return throwVMTypeError(state);
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D1(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texSubImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 9))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(6), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(7), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto pixels = toArrayBufferView(state->argument(8));
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.texSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(width), WTFMove(height), WTFMove(format), WTFMove(type), WTFMove(pixels), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D2(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texSubImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    ImageData* pixels = nullptr;
    if (!state->argument(6).isUndefinedOrNull()) {
        pixels = JSImageData::toWrapped(state->uncheckedArgument(6));
        if (UNLIKELY(!pixels))
            return throwArgumentTypeError(*state, 6, "pixels", "WebGLRenderingContextBase", "texSubImage2D", "ImageData");
    }
    impl.texSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(format), WTFMove(type), pixels, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D3(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texSubImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLImageElement* image = nullptr;
    if (!state->argument(6).isUndefinedOrNull()) {
        image = JSHTMLImageElement::toWrapped(state->uncheckedArgument(6));
        if (UNLIKELY(!image))
            return throwArgumentTypeError(*state, 6, "image", "WebGLRenderingContextBase", "texSubImage2D", "HTMLImageElement");
    }
    impl.texSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(format), WTFMove(type), image, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D4(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texSubImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLCanvasElement* canvas = nullptr;
    if (!state->argument(6).isUndefinedOrNull()) {
        canvas = JSHTMLCanvasElement::toWrapped(state->uncheckedArgument(6));
        if (UNLIKELY(!canvas))
            return throwArgumentTypeError(*state, 6, "canvas", "WebGLRenderingContextBase", "texSubImage2D", "HTMLCanvasElement");
    }
    impl.texSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(format), WTFMove(type), canvas, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

static inline EncodedJSValue jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D5(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "texSubImage2D");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto target = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto level = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto xoffset = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto yoffset = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto format = convert<uint32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    HTMLVideoElement* video = nullptr;
    if (!state->argument(6).isUndefinedOrNull()) {
        video = JSHTMLVideoElement::toWrapped(state->uncheckedArgument(6));
        if (UNLIKELY(!video))
            return throwArgumentTypeError(*state, 6, "video", "WebGLRenderingContextBase", "texSubImage2D", "HTMLVideoElement");
    }
    impl.texSubImage2D(WTFMove(target), WTFMove(level), WTFMove(xoffset), WTFMove(yoffset), WTFMove(format), WTFMove(type), video, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D(ExecState* state)
{
    size_t argsCount = std::min<size_t>(9, state->argumentCount());
    JSValue arg8(state->argument(8));
    if ((argsCount == 9 && (arg8.isUndefinedOrNull() || (arg8.isObject() && asObject(arg8)->inherits(JSArrayBufferView::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D1(state);
    JSValue arg6(state->argument(6));
    if ((argsCount == 7 && (arg6.isUndefinedOrNull() || (arg6.isObject() && asObject(arg6)->inherits(JSImageData::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D2(state);
    if ((argsCount == 7 && (arg6.isUndefinedOrNull() || (arg6.isObject() && asObject(arg6)->inherits(JSHTMLImageElement::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D3(state);
    if ((argsCount == 7 && (arg6.isUndefinedOrNull() || (arg6.isObject() && asObject(arg6)->inherits(JSHTMLCanvasElement::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D4(state);
    if ((argsCount == 7 && (arg6.isUndefinedOrNull() || (arg6.isObject() && asObject(arg6)->inherits(JSHTMLVideoElement::info())))))
        return jsWebGLRenderingContextBasePrototypeFunctionTexSubImage2D5(state);
    if (UNLIKELY(argsCount < 7))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    return throwVMTypeError(state);
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1f(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform1f");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGLRenderingContextBase", "uniform1f", "WebGLUniformLocation");
    }
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform1f(location, WTFMove(x), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform1fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniform1fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1i(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform1i");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGLRenderingContextBase", "uniform1i", "WebGLUniformLocation");
    }
    auto x = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform1i(location, WTFMove(x), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform1iv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform1iv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniform1iv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2f(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform2f");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGLRenderingContextBase", "uniform2f", "WebGLUniformLocation");
    }
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform2f(location, WTFMove(x), WTFMove(y), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform2fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniform2fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2i(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform2i");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGLRenderingContextBase", "uniform2i", "WebGLUniformLocation");
    }
    auto x = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform2i(location, WTFMove(x), WTFMove(y), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform2iv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform2iv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniform2iv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3f(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform3f");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGLRenderingContextBase", "uniform3f", "WebGLUniformLocation");
    }
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto z = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform3f(location, WTFMove(x), WTFMove(y), WTFMove(z), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform3fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniform3fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3i(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform3i");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGLRenderingContextBase", "uniform3i", "WebGLUniformLocation");
    }
    auto x = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto z = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform3i(location, WTFMove(x), WTFMove(y), WTFMove(z), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform3iv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform3iv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniform3iv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4f(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform4f");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGLRenderingContextBase", "uniform4f", "WebGLUniformLocation");
    }
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto z = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto w = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform4f(location, WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform4fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniform4fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4i(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform4i");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLUniformLocation* location = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        location = JSWebGLUniformLocation::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!location))
            return throwArgumentTypeError(*state, 0, "location", "WebGLRenderingContextBase", "uniform4i", "WebGLUniformLocation");
    }
    auto x = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto z = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto w = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.uniform4i(location, WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniform4iv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniform4iv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniform4iv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix2fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniformMatrix2fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniformMatrix2fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix3fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniformMatrix3fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniformMatrix3fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUniformMatrix4fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "uniformMatrix4fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->uniformMatrix4fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionUseProgram(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "useProgram");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "useProgram", "WebGLProgram");
    }
    impl.useProgram(program, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionValidateProgram(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "validateProgram");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 1))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    WebGLProgram* program = nullptr;
    if (!state->argument(0).isUndefinedOrNull()) {
        program = JSWebGLProgram::toWrapped(state->uncheckedArgument(0));
        if (UNLIKELY(!program))
            return throwArgumentTypeError(*state, 0, "program", "WebGLRenderingContextBase", "validateProgram", "WebGLProgram");
    }
    impl.validateProgram(program, ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1f(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttrib1f");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 2))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto indx = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttrib1f(WTFMove(indx), WTFMove(x));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib1fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttrib1fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->vertexAttrib1fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2f(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttrib2f");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 3))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto indx = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttrib2f(WTFMove(indx), WTFMove(x), WTFMove(y));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib2fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttrib2fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->vertexAttrib2fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3f(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttrib3f");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto indx = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto z = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttrib3f(WTFMove(indx), WTFMove(x), WTFMove(y), WTFMove(z));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib3fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttrib3fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->vertexAttrib3fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4f(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttrib4f");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 5))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto indx = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto x = convert<float>(*state, state->argument(1), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<float>(*state, state->argument(2), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto z = convert<float>(*state, state->argument(3), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto w = convert<float>(*state, state->argument(4), ShouldAllowNonFinite::Yes);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttrib4f(WTFMove(indx), WTFMove(x), WTFMove(y), WTFMove(z), WTFMove(w));
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttrib4fv(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttrib4fv");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    return JSValue::encode(castedThis->vertexAttrib4fv(*state));
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionVertexAttribPointer(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "vertexAttribPointer");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 6))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    ExceptionCode ec = 0;
    auto indx = convert<uint32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto size = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto type = convert<uint32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto normalized = state->argument(3).toBoolean(state);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto stride = convert<int32_t>(*state, state->argument(4), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto offset = convert<int64_t>(*state, state->argument(5), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.vertexAttribPointer(WTFMove(indx), WTFMove(size), WTFMove(type), WTFMove(normalized), WTFMove(stride), WTFMove(offset), ec);
    setDOMException(state, ec);
    return JSValue::encode(jsUndefined());
}

EncodedJSValue JSC_HOST_CALL jsWebGLRenderingContextBasePrototypeFunctionViewport(ExecState* state)
{
    JSValue thisValue = state->thisValue();
    auto castedThis = jsDynamicCast<JSWebGLRenderingContextBase*>(thisValue);
    if (UNLIKELY(!castedThis))
        return throwThisTypeError(*state, "WebGLRenderingContextBase", "viewport");
    ASSERT_GC_OBJECT_INHERITS(castedThis, JSWebGLRenderingContextBase::info());
    auto& impl = castedThis->wrapped();
    if (UNLIKELY(state->argumentCount() < 4))
        return throwVMError(state, createNotEnoughArgumentsError(state));
    auto x = convert<int32_t>(*state, state->argument(0), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto y = convert<int32_t>(*state, state->argument(1), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto width = convert<int32_t>(*state, state->argument(2), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    auto height = convert<int32_t>(*state, state->argument(3), NormalConversion);
    if (UNLIKELY(state->hadException()))
        return JSValue::encode(jsUndefined());
    impl.viewport(WTFMove(x), WTFMove(y), WTFMove(width), WTFMove(height));
    return JSValue::encode(jsUndefined());
}

void JSWebGLRenderingContextBase::visitChildren(JSCell* cell, SlotVisitor& visitor)
{
    auto* thisObject = jsCast<JSWebGLRenderingContextBase*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
    Base::visitChildren(thisObject, visitor);
    thisObject->visitAdditionalChildren(visitor);
}


}

#endif // ENABLE(WEBGL)
