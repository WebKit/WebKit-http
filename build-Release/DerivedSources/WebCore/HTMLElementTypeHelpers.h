/*
 * THIS FILE WAS AUTOMATICALLY GENERATED, DO NOT EDIT.
 *
 * This file was generated by the dom/make_names.pl script.
 *
 * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2013 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef HTMLElementTypeHelpers_h
#define HTMLElementTypeHelpers_h

#include "HTMLNames.h"

namespace WebCore {
class HTMLAnchorElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLAnchorElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::aTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::aTag); }
};
}

namespace WebCore {
class HTMLAppletElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLAppletElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::appletTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::appletTag); }
};
}

namespace WebCore {
class HTMLAreaElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLAreaElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::areaTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::areaTag); }
};
}

namespace WebCore {
class HTMLAttachmentElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLAttachmentElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return !element.isHTMLUnknownElement() && element.hasTagName(WebCore::HTMLNames::attachmentTag); }
    static bool checkTagName(const WebCore::Node& node) { return is<WebCore::HTMLElement>(node) && checkTagName(downcast<WebCore::HTMLElement>(node)); }
};
}

namespace WebCore {
class HTMLBDIElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLBDIElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::bdiTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::bdiTag); }
};
}

namespace WebCore {
class HTMLBRElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLBRElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::brTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::brTag); }
};
}

namespace WebCore {
class HTMLBaseElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLBaseElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::baseTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::baseTag); }
};
}

namespace WebCore {
class HTMLBodyElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLBodyElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::bodyTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::bodyTag); }
};
}

namespace WebCore {
class HTMLButtonElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLButtonElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::buttonTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::buttonTag); }
};
}

namespace WebCore {
class HTMLCanvasElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLCanvasElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::canvasTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::canvasTag); }
};
}

namespace WebCore {
class HTMLDListElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLDListElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::dlTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::dlTag); }
};
}

namespace WebCore {
class HTMLDataElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLDataElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::dataTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::dataTag); }
};
}

namespace WebCore {
class HTMLDataListElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLDataListElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::datalistTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::datalistTag); }
};
}

namespace WebCore {
class HTMLDetailsElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLDetailsElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::detailsTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::detailsTag); }
};
}

namespace WebCore {
class HTMLDirectoryElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLDirectoryElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::dirTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::dirTag); }
};
}

namespace WebCore {
class HTMLDivElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLDivElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::divTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::divTag); }
};
}

namespace WebCore {
class HTMLEmbedElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLEmbedElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::embedTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::embedTag); }
};
}

namespace WebCore {
class HTMLFieldSetElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLFieldSetElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::fieldsetTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::fieldsetTag); }
};
}

namespace WebCore {
class HTMLFontElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLFontElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::fontTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::fontTag); }
};
}

namespace WebCore {
class HTMLFormElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLFormElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::formTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::formTag); }
};
}

namespace WebCore {
class HTMLFrameElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLFrameElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::frameTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::frameTag); }
};
}

namespace WebCore {
class HTMLFrameSetElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLFrameSetElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::framesetTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::framesetTag); }
};
}

namespace WebCore {
class HTMLHRElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLHRElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::hrTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::hrTag); }
};
}

namespace WebCore {
class HTMLHeadElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLHeadElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::headTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::headTag); }
};
}

namespace WebCore {
class HTMLHtmlElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLHtmlElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::htmlTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::htmlTag); }
};
}

namespace WebCore {
class HTMLIFrameElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLIFrameElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::iframeTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::iframeTag); }
};
}

namespace WebCore {
class HTMLImageElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLImageElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::imgTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::imgTag); }
};
}

namespace WebCore {
class HTMLInputElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLInputElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::inputTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::inputTag); }
};
}

namespace WebCore {
class HTMLKeygenElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLKeygenElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::keygenTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::keygenTag); }
};
}

namespace WebCore {
class HTMLLIElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLLIElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::liTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::liTag); }
};
}

namespace WebCore {
class HTMLLabelElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLLabelElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::labelTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::labelTag); }
};
}

namespace WebCore {
class HTMLLegendElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLLegendElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::legendTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::legendTag); }
};
}

namespace WebCore {
class HTMLLinkElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLLinkElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::linkTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::linkTag); }
};
}

namespace WebCore {
class HTMLMapElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLMapElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::mapTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::mapTag); }
};
}

namespace WebCore {
class HTMLMarqueeElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLMarqueeElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::marqueeTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::marqueeTag); }
};
}

namespace WebCore {
class HTMLMenuElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLMenuElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::menuTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::menuTag); }
};
}

namespace WebCore {
class HTMLMetaElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLMetaElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::metaTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::metaTag); }
};
}

namespace WebCore {
class HTMLMeterElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLMeterElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::meterTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::meterTag); }
};
}

namespace WebCore {
class HTMLOListElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLOListElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::olTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::olTag); }
};
}

namespace WebCore {
class HTMLObjectElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLObjectElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::objectTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::objectTag); }
};
}

namespace WebCore {
class HTMLOptGroupElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLOptGroupElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::optgroupTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::optgroupTag); }
};
}

namespace WebCore {
class HTMLOptionElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLOptionElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::optionTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::optionTag); }
};
}

namespace WebCore {
class HTMLOutputElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLOutputElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::outputTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::outputTag); }
};
}

namespace WebCore {
class HTMLParagraphElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLParagraphElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::pTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::pTag); }
};
}

namespace WebCore {
class HTMLParamElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLParamElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::paramTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::paramTag); }
};
}

namespace WebCore {
class HTMLPictureElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLPictureElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::pictureTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::pictureTag); }
};
}

namespace WebCore {
class HTMLProgressElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLProgressElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::progressTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::progressTag); }
};
}

namespace WebCore {
class HTMLScriptElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLScriptElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::scriptTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::scriptTag); }
};
}

namespace WebCore {
class HTMLSelectElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLSelectElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::selectTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::selectTag); }
};
}

namespace WebCore {
class HTMLSlotElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLSlotElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::slotTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::slotTag); }
};
}

namespace WebCore {
class HTMLSourceElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLSourceElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::sourceTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::sourceTag); }
};
}

namespace WebCore {
class HTMLSpanElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLSpanElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::spanTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::spanTag); }
};
}

namespace WebCore {
class HTMLStyleElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLStyleElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::styleTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::styleTag); }
};
}

namespace WebCore {
class HTMLSummaryElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLSummaryElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::summaryTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::summaryTag); }
};
}

namespace WebCore {
class HTMLTableCaptionElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLTableCaptionElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::captionTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::captionTag); }
};
}

namespace WebCore {
class HTMLTableElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLTableElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::tableTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::tableTag); }
};
}

namespace WebCore {
class HTMLTableRowElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLTableRowElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::trTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::trTag); }
};
}

namespace WebCore {
class HTMLTemplateElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLTemplateElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::templateTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::templateTag); }
};
}

namespace WebCore {
class HTMLTextAreaElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLTextAreaElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::textareaTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::textareaTag); }
};
}

namespace WebCore {
class HTMLTimeElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLTimeElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::timeTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::timeTag); }
};
}

namespace WebCore {
class HTMLTitleElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLTitleElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::titleTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::titleTag); }
};
}

namespace WebCore {
class HTMLTrackElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLTrackElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return !element.isHTMLUnknownElement() && element.hasTagName(WebCore::HTMLNames::trackTag); }
    static bool checkTagName(const WebCore::Node& node) { return is<WebCore::HTMLElement>(node) && checkTagName(downcast<WebCore::HTMLElement>(node)); }
};
}

namespace WebCore {
class HTMLUListElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLUListElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::ulTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::ulTag); }
};
}

namespace WebCore {
class HTMLWBRElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::HTMLWBRElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::wbrTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::wbrTag); }
};
}

namespace WebCore {
class RubyElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::RubyElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::rubyTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::rubyTag); }
};
}

namespace WebCore {
class RubyTextElement;
}
namespace WTF {
template <typename ArgType>
class TypeCastTraits<const WebCore::RubyTextElement, ArgType, false /* isBaseType */> {
public:
    static bool isOfType(ArgType& node) { return checkTagName(node); }
private:
    static bool checkTagName(const WebCore::HTMLElement& element) { return element.hasTagName(WebCore::HTMLNames::rtTag); }
    static bool checkTagName(const WebCore::Node& node) { return node.hasTagName(WebCore::HTMLNames::rtTag); }
};
}

#endif
