/*
 * Copyright (c) 2014, 2015, 2016 -2016 Apple Inc. All rights reserved.
 * Copyright (c) 2014, 2015, 2016 Apple Inc. All rights reserved.
 * Copyright (c) 2015 Andy VanWagoner <thetalecrafter@gmail.com>.
 * Copyright (c) 2015 Jordan Harband. All rights reserved.
 * Copyright (c) 2015, 2016 -2016 Yusuke Suzuki <utatane.tea@gmail.com>.
 * Copyright (c) 2015, 2016 Yusuke Suzuki <utatane.tea@gmail.com>.
 * Copyright (c) 2016 Oleksandr Skachkov <gskachkov@gmail.com>.
 * Copyright (c) 2016 Yusuke Suzuki <utatane.tea@gmail.com>
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */

// DO NOT EDIT THIS FILE. It is automatically generated from JavaScript files for
// builtins by the script: Source/JavaScriptCore/Scripts/generate-js-builtins.py

#include "config.h"
#include "JSCBuiltins.h"

#include "BuiltinExecutables.h"
#include "Executable.h"
#include "Intrinsic.h"
#include "JSCellInlines.h"
#include "VM.h"

namespace JSC {

const JSC::ConstructAbility s_generatorPrototypeThrowCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_generatorPrototypeThrowCodeLength = 118;
static const JSC::Intrinsic s_generatorPrototypeThrowCodeIntrinsic = JSC::NoIntrinsic;
const char* s_generatorPrototypeThrowCode =
    "(function (exception)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return @generatorResume(this, exception, @GeneratorResumeModeThrow);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_globalObjectIsFiniteCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_globalObjectIsFiniteCodeLength = 208;
static const JSC::Intrinsic s_globalObjectIsFiniteCodeIntrinsic = JSC::NoIntrinsic;
const char* s_globalObjectIsFiniteCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var numberValue = @toNumber(value);\n" \
    "    if (numberValue !== numberValue)\n" \
    "        return false;\n" \
    "    return numberValue !== @Infinity && numberValue !== -@Infinity;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_globalObjectIsNaNCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_globalObjectIsNaNCodeLength = 121;
static const JSC::Intrinsic s_globalObjectIsNaNCodeIntrinsic = JSC::NoIntrinsic;
const char* s_globalObjectIsNaNCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var numberValue = @toNumber(value);\n" \
    "    return numberValue !== numberValue;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_globalOperationsToIntegerCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_globalOperationsToIntegerCodeLength = 168;
static const JSC::Intrinsic s_globalOperationsToIntegerCodeIntrinsic = JSC::NoIntrinsic;
const char* s_globalOperationsToIntegerCode =
    "(function (target)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var numberValue = @Number(target);\n" \
    "    if (numberValue !== numberValue)\n" \
    "        return 0;\n" \
    "    return @trunc(numberValue);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_globalOperationsToLengthCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_globalOperationsToLengthCodeLength = 166;
static const JSC::Intrinsic s_globalOperationsToLengthCodeIntrinsic = JSC::NoIntrinsic;
const char* s_globalOperationsToLengthCode =
    "(function (target)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @toInteger(target);\n" \
    "    return length > 0 ? (length < @MAX_SAFE_INTEGER ? length : @MAX_SAFE_INTEGER) : 0;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_globalOperationsIsDictionaryCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_globalOperationsIsDictionaryCodeLength = 99;
static const JSC::Intrinsic s_globalOperationsIsDictionaryCodeIntrinsic = JSC::NoIntrinsic;
const char* s_globalOperationsIsDictionaryCode =
    "(function (object)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return object == null || typeof object === \"object\";\n" \
    "})\n" \
;

const JSC::ConstructAbility s_globalOperationsSpeciesGetterCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_globalOperationsSpeciesGetterCodeLength = 35;
static const JSC::Intrinsic s_globalOperationsSpeciesGetterCodeIntrinsic = JSC::NoIntrinsic;
const char* s_globalOperationsSpeciesGetterCode =
    "(function ()\n" \
    "{\n" \
    "    return this;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_globalOperationsSpeciesConstructorCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_globalOperationsSpeciesConstructorCodeLength = 526;
static const JSC::Intrinsic s_globalOperationsSpeciesConstructorCodeIntrinsic = JSC::NoIntrinsic;
const char* s_globalOperationsSpeciesConstructorCode =
    "(function (obj, defaultConstructor)\n" \
    "{\n" \
    "    var constructor = obj.constructor;\n" \
    "    if (constructor === @undefined)\n" \
    "        return defaultConstructor;\n" \
    "    if (!@isObject(constructor))\n" \
    "        throw new @TypeError(\"|this|.constructor is not an Object or undefined\");\n" \
    "    constructor = constructor.@speciesSymbol;\n" \
    "    if (constructor == null)\n" \
    "        return defaultConstructor;\n" \
    "    if (@isConstructor(constructor))\n" \
    "        return constructor;\n" \
    "    throw new @TypeError(\"|this|.constructor[Symbol.species] is not a constructor\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_inspectorInstrumentationObjectPromiseFulfilledCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_inspectorInstrumentationObjectPromiseFulfilledCodeLength = 102;
static const JSC::Intrinsic s_inspectorInstrumentationObjectPromiseFulfilledCodeIntrinsic = JSC::NoIntrinsic;
const char* s_inspectorInstrumentationObjectPromiseFulfilledCode =
    "(function (promise, value, reactions)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!this.isEnabled)\n" \
    "        return;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_inspectorInstrumentationObjectPromiseRejectedCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_inspectorInstrumentationObjectPromiseRejectedCodeLength = 103;
static const JSC::Intrinsic s_inspectorInstrumentationObjectPromiseRejectedCodeIntrinsic = JSC::NoIntrinsic;
const char* s_inspectorInstrumentationObjectPromiseRejectedCode =
    "(function (promise, reason, reactions)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!this.isEnabled)\n" \
    "        return;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_internalPromiseConstructorInternalAllCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_internalPromiseConstructorInternalAllCodeLength = 1536;
static const JSC::Intrinsic s_internalPromiseConstructorInternalAllCodeIntrinsic = JSC::NoIntrinsic;
const char* s_internalPromiseConstructorInternalAllCode =
    "(function (array)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var promiseCapability = @newPromiseCapability(@InternalPromise);\n" \
    "    var values = [];\n" \
    "    var index = 0;\n" \
    "    var remainingElementsCount = 0;\n" \
    "    function newResolveElement(index)\n" \
    "    {\n" \
    "        var alreadyCalled = false;\n" \
    "        return function (argument)\n" \
    "        {\n" \
    "            if (alreadyCalled)\n" \
    "                return @undefined;\n" \
    "            alreadyCalled = true;\n" \
    "            @putByValDirect(values, index, argument);\n" \
    "            --remainingElementsCount;\n" \
    "            if (remainingElementsCount === 0)\n" \
    "                return promiseCapability.@resolve.@call(@undefined, values);\n" \
    "            return @undefined;\n" \
    "        }\n" \
    "    }\n" \
    "    try {\n" \
    "        if (array.length === 0)\n" \
    "            promiseCapability.@resolve.@call(@undefined, values);\n" \
    "        else {\n" \
    "            for (var index = 0, length = array.length; index < length; ++index) {\n" \
    "                var value = array[index];\n" \
    "                @putByValDirect(values, index, @undefined);\n" \
    "                var nextPromiseCapability = @newPromiseCapability(@InternalPromise);\n" \
    "                nextPromiseCapability.@resolve.@call(@undefined, value);\n" \
    "                var nextPromise = nextPromiseCapability.@promise;\n" \
    "                var resolveElement = newResolveElement(index);\n" \
    "                ++remainingElementsCount;\n" \
    "                nextPromise.then(resolveElement, promiseCapability.@reject);\n" \
    "            }\n" \
    "        }\n" \
    "    } catch (error) {\n" \
    "        promiseCapability.@reject.@call(@undefined, error);\n" \
    "    }\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_iteratorPrototypeSymbolIteratorGetterCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_iteratorPrototypeSymbolIteratorGetterCodeLength = 53;
static const JSC::Intrinsic s_iteratorPrototypeSymbolIteratorGetterCodeIntrinsic = JSC::NoIntrinsic;
const char* s_iteratorPrototypeSymbolIteratorGetterCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return this;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_mapPrototypeForEachCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_mapPrototypeForEachCodeLength = 566;
static const JSC::Intrinsic s_mapPrototypeForEachCodeIntrinsic = JSC::NoIntrinsic;
const char* s_mapPrototypeForEachCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isMap(this))\n" \
    "        throw new @TypeError(\"Map operation called on non-Map object\");\n" \
    "    if (typeof callback !== 'function')\n" \
    "        throw new @TypeError(\"Map.prototype.forEach callback must be a function\");\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    var iterator = @MapIterator(this);\n" \
    "    var value = [ @undefined, @undefined ];\n" \
    "    for (;;) {\n" \
    "        if (@mapIteratorNext.@call(iterator, value))\n" \
    "            break;\n" \
    "        callback.@call(thisArg, value[1], value[0], this);\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeSetStateToMaxCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeSetStateToMaxCodeLength = 115;
static const JSC::Intrinsic s_moduleLoaderPrototypeSetStateToMaxCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeSetStateToMaxCode =
    "(function (entry, newState)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (entry.state < newState)\n" \
    "        entry.state = newState;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeNewRegistryEntryCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeNewRegistryEntryCodeLength = 386;
static const JSC::Intrinsic s_moduleLoaderPrototypeNewRegistryEntryCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeNewRegistryEntryCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return {\n" \
    "        key: key,\n" \
    "        state: @ModuleFetch,\n" \
    "        metadata: @undefined,\n" \
    "        fetch: @undefined,\n" \
    "        translate: @undefined,\n" \
    "        instantiate: @undefined,\n" \
    "        resolveDependencies: @undefined,\n" \
    "        dependencies: [],\n" \
    "        dependenciesMap: @undefined,\n" \
    "        module: @undefined,\n" \
    "        error: @undefined,\n" \
    "    };\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeEnsureRegisteredCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeEnsureRegisteredCodeLength = 211;
static const JSC::Intrinsic s_moduleLoaderPrototypeEnsureRegisteredCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeEnsureRegisteredCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var entry = this.registry.@get(key);\n" \
    "    if (entry)\n" \
    "        return entry;\n" \
    "    entry = this.newRegistryEntry(key);\n" \
    "    this.registry.@set(key, entry);\n" \
    "    return entry;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeForceFulfillPromiseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeForceFulfillPromiseCodeLength = 147;
static const JSC::Intrinsic s_moduleLoaderPrototypeForceFulfillPromiseCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeForceFulfillPromiseCode =
    "(function (promise, value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (promise.@promiseState === @promiseStatePending)\n" \
    "        @fulfillPromise(promise, value);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeFulfillFetchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeFulfillFetchCodeLength = 245;
static const JSC::Intrinsic s_moduleLoaderPrototypeFulfillFetchCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeFulfillFetchCode =
    "(function (entry, payload)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!entry.fetch)\n" \
    "        entry.fetch = @newPromiseCapability(@InternalPromise).@promise;\n" \
    "    this.forceFulfillPromise(entry.fetch, payload);\n" \
    "    this.setStateToMax(entry, @ModuleTranslate);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeFulfillTranslateCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeFulfillTranslateCodeLength = 257;
static const JSC::Intrinsic s_moduleLoaderPrototypeFulfillTranslateCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeFulfillTranslateCode =
    "(function (entry, source)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!entry.translate)\n" \
    "        entry.translate = @newPromiseCapability(@InternalPromise).@promise;\n" \
    "    this.forceFulfillPromise(entry.translate, source);\n" \
    "    this.setStateToMax(entry, @ModuleInstantiate);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeFulfillInstantiateCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeFulfillInstantiateCodeLength = 291;
static const JSC::Intrinsic s_moduleLoaderPrototypeFulfillInstantiateCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeFulfillInstantiateCode =
    "(function (entry, optionalInstance, source)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!entry.instantiate)\n" \
    "        entry.instantiate = @newPromiseCapability(@InternalPromise).@promise;\n" \
    "    this.commitInstantiated(entry, optionalInstance, source);\n" \
    "    this.forceFulfillPromise(entry.instantiate, entry);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeCommitInstantiatedCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeCommitInstantiatedCodeLength = 806;
static const JSC::Intrinsic s_moduleLoaderPrototypeCommitInstantiatedCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeCommitInstantiatedCode =
    "(function (entry, optionalInstance, source)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var moduleRecord = this.instantiation(optionalInstance, source, entry);\n" \
    "    var dependencies = [];\n" \
    "    var dependenciesMap = moduleRecord.dependenciesMap;\n" \
    "    moduleRecord.registryEntry = entry;\n" \
    "    var requestedModules = this.requestedModules(moduleRecord);\n" \
    "    for (var i = 0, length = requestedModules.length; i < length; ++i) {\n" \
    "        var depKey = requestedModules[i];\n" \
    "        var pair = {\n" \
    "            key: depKey,\n" \
    "            value: @undefined\n" \
    "        };\n" \
    "        @putByValDirect(dependencies, i, pair);\n" \
    "        dependenciesMap.@set(depKey, pair);\n" \
    "    }\n" \
    "    entry.dependencies = dependencies;\n" \
    "    entry.dependenciesMap = dependenciesMap;\n" \
    "    entry.module = moduleRecord;\n" \
    "    this.setStateToMax(entry, @ModuleResolveDependencies);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeInstantiationCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeInstantiationCodeLength = 105;
static const JSC::Intrinsic s_moduleLoaderPrototypeInstantiationCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeInstantiationCode =
    "(function (result, source, entry)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return this.parseModule(entry.key, source);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeRequestFetchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeRequestFetchCodeLength = 618;
static const JSC::Intrinsic s_moduleLoaderPrototypeRequestFetchCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeRequestFetchCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var entry = this.ensureRegistered(key);\n" \
    "    if (entry.state > @ModuleLink) {\n" \
    "        var deferred = @newPromiseCapability(@InternalPromise);\n" \
    "        deferred.@reject.@call(@undefined, new @TypeError(\"Requested module is already ready to be executed.\"));\n" \
    "        return deferred.@promise;\n" \
    "    }\n" \
    "    if (entry.fetch)\n" \
    "        return entry.fetch;\n" \
    "    var loader = this;\n" \
    "    var fetchPromise = this.fetch(key).then(function (payload) {\n" \
    "        loader.setStateToMax(entry, @ModuleTranslate);\n" \
    "        return payload;\n" \
    "    });\n" \
    "    entry.fetch = fetchPromise;\n" \
    "    return fetchPromise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeRequestTranslateCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeRequestTranslateCodeLength = 741;
static const JSC::Intrinsic s_moduleLoaderPrototypeRequestTranslateCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeRequestTranslateCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var entry = this.ensureRegistered(key);\n" \
    "    if (entry.state > @ModuleLink) {\n" \
    "        var deferred = @newPromiseCapability(@InternalPromise);\n" \
    "        deferred.@reject.@call(@undefined, new @TypeError(\"Requested module is already ready to be executed.\"));\n" \
    "        return deferred.@promise;\n" \
    "    }\n" \
    "    if (entry.translate)\n" \
    "        return entry.translate;\n" \
    "    var loader = this;\n" \
    "    var translatePromise = this.requestFetch(key).then(function (payload) {\n" \
    "        return loader.translate(key, payload).then(function (source) {\n" \
    "            loader.setStateToMax(entry, @ModuleInstantiate);\n" \
    "            return source;\n" \
    "        });\n" \
    "    });\n" \
    "    entry.translate = translatePromise;\n" \
    "    return translatePromise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeRequestInstantiateCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeRequestInstantiateCodeLength = 777;
static const JSC::Intrinsic s_moduleLoaderPrototypeRequestInstantiateCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeRequestInstantiateCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var entry = this.ensureRegistered(key);\n" \
    "    if (entry.state > @ModuleLink) {\n" \
    "        var deferred = @newPromiseCapability(@InternalPromise);\n" \
    "        deferred.@reject.@call(@undefined, new @TypeError(\"Requested module is already ready to be executed.\"));\n" \
    "        return deferred.@promise;\n" \
    "    }\n" \
    "    if (entry.instantiate)\n" \
    "        return entry.instantiate;\n" \
    "    var loader = this;\n" \
    "    var instantiatePromise = this.requestTranslate(key).then(function (source) {\n" \
    "        return loader.instantiate(key, source).then(function (optionalInstance) {\n" \
    "            loader.commitInstantiated(entry, optionalInstance, source);\n" \
    "            return entry;\n" \
    "        });\n" \
    "    });\n" \
    "    entry.instantiate = instantiatePromise;\n" \
    "    return instantiatePromise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeRequestResolveDependenciesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeRequestResolveDependenciesCodeLength = 1625;
static const JSC::Intrinsic s_moduleLoaderPrototypeRequestResolveDependenciesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeRequestResolveDependenciesCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var entry = this.ensureRegistered(key);\n" \
    "    if (entry.state > @ModuleLink) {\n" \
    "        var deferred = @newPromiseCapability(@InternalPromise);\n" \
    "        deferred.@reject.@call(@undefined, new @TypeError(\"Requested module is already ready to be executed.\"));\n" \
    "        return deferred.@promise;\n" \
    "    }\n" \
    "    if (entry.resolveDependencies)\n" \
    "        return entry.resolveDependencies;\n" \
    "    var loader = this;\n" \
    "    var resolveDependenciesPromise = this.requestInstantiate(key).then(function (entry) {\n" \
    "        var depLoads = [];\n" \
    "        for (var i = 0, length = entry.dependencies.length; i < length; ++i) {\n" \
    "            let pair = entry.dependencies[i];\n" \
    "            var promise = loader.resolve(pair.key, key).then(function (depKey) {\n" \
    "                var depEntry = loader.ensureRegistered(depKey);\n" \
    "                if (depEntry.resolveDependencies) {\n" \
    "                    return depEntry.instantiate.then(function (entry) {\n" \
    "                        pair.value = entry.module;\n" \
    "                        return entry;\n" \
    "                    });\n" \
    "                }\n" \
    "                return loader.requestResolveDependencies(depKey).then(function (entry) {\n" \
    "                    pair.value = entry.module;\n" \
    "                    return entry;\n" \
    "                });\n" \
    "            });\n" \
    "            @putByValDirect(depLoads, i, promise);\n" \
    "        }\n" \
    "        return @InternalPromise.internalAll(depLoads).then(function (modules) {\n" \
    "            loader.setStateToMax(entry, @ModuleLink);\n" \
    "            return entry;\n" \
    "        });\n" \
    "    });\n" \
    "    entry.resolveDependencies = resolveDependenciesPromise;\n" \
    "    return resolveDependenciesPromise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeRequestInstantiateAllCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeRequestInstantiateAllCodeLength = 88;
static const JSC::Intrinsic s_moduleLoaderPrototypeRequestInstantiateAllCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeRequestInstantiateAllCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return this.requestResolveDependencies(key);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeRequestLinkCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeRequestLinkCodeLength = 431;
static const JSC::Intrinsic s_moduleLoaderPrototypeRequestLinkCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeRequestLinkCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var entry = this.ensureRegistered(key);\n" \
    "    if (entry.state > @ModuleLink) {\n" \
    "        var deferred = @newPromiseCapability(@InternalPromise);\n" \
    "        deferred.@resolve.@call(@undefined, entry.module);\n" \
    "        return deferred.@promise;\n" \
    "    }\n" \
    "    var loader = this;\n" \
    "    return this.requestInstantiateAll(key).then(function (entry) {\n" \
    "        loader.link(entry);\n" \
    "        return entry;\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeRequestReadyCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeRequestReadyCodeLength = 174;
static const JSC::Intrinsic s_moduleLoaderPrototypeRequestReadyCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeRequestReadyCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var loader = this;\n" \
    "    return this.requestLink(key).then(function (entry) {\n" \
    "        loader.moduleEvaluation(entry.module);\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeLinkCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeLinkCodeLength = 394;
static const JSC::Intrinsic s_moduleLoaderPrototypeLinkCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeLinkCode =
    "(function (entry)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (entry.state === @ModuleReady)\n" \
    "        return;\n" \
    "    this.setStateToMax(entry, @ModuleReady);\n" \
    "    var dependencies = entry.dependencies;\n" \
    "    for (var i = 0, length = dependencies.length; i < length; ++i) {\n" \
    "        var pair = dependencies[i];\n" \
    "        this.link(pair.value.registryEntry);\n" \
    "    }\n" \
    "    this.moduleDeclarationInstantiation(entry.module);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeModuleEvaluationCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeModuleEvaluationCodeLength = 473;
static const JSC::Intrinsic s_moduleLoaderPrototypeModuleEvaluationCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeModuleEvaluationCode =
    "(function (moduleRecord)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (moduleRecord.evaluated)\n" \
    "        return;\n" \
    "    moduleRecord.evaluated = true;\n" \
    "    var entry = moduleRecord.registryEntry;\n" \
    "    var dependencies = entry.dependencies;\n" \
    "    for (var i = 0, length = dependencies.length; i < length; ++i) {\n" \
    "        var pair = dependencies[i];\n" \
    "        var requiredModuleRecord = pair.value;\n" \
    "        this.moduleEvaluation(requiredModuleRecord);\n" \
    "    }\n" \
    "    this.evaluate(entry.key, moduleRecord);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeProvideCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeProvideCodeLength = 1089;
static const JSC::Intrinsic s_moduleLoaderPrototypeProvideCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeProvideCode =
    "(function (key, stage, value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var entry = this.ensureRegistered(key);\n" \
    "    if (stage === @ModuleFetch) {\n" \
    "        if (entry.status > @ModuleFetch)\n" \
    "            throw new @TypeError(\"Requested module is already fetched.\");\n" \
    "        this.fulfillFetch(entry, value);\n" \
    "        return;\n" \
    "    }\n" \
    "    if (stage === @ModuleTranslate) {\n" \
    "        if (entry.status > @ModuleTranslate)\n" \
    "            throw new @TypeError(\"Requested module is already translated.\");\n" \
    "        this.fulfillFetch(entry, @undefined);\n" \
    "        this.fulfillTranslate(entry, value);\n" \
    "        return;\n" \
    "    }\n" \
    "    if (stage === @ModuleInstantiate) {\n" \
    "        if (entry.status > @ModuleInstantiate)\n" \
    "            throw new @TypeError(\"Requested module is already instantiated.\");\n" \
    "        this.fulfillFetch(entry, @undefined);\n" \
    "        this.fulfillTranslate(entry, value);\n" \
    "        var loader = this;\n" \
    "        entry.translate.then(function (source) {\n" \
    "            loader.fulfillInstantiate(entry, value, source);\n" \
    "        });\n" \
    "        return;\n" \
    "    }\n" \
    "    throw new @TypeError(\"Requested module is already ready to be executed.\");\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeLoadAndEvaluateModuleCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeLoadAndEvaluateModuleCodeLength = 196;
static const JSC::Intrinsic s_moduleLoaderPrototypeLoadAndEvaluateModuleCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeLoadAndEvaluateModuleCode =
    "(function (moduleName, referrer)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var loader = this;\n" \
    "    return this.resolve(moduleName, referrer).then(function (key) {\n" \
    "        return loader.requestReady(key);\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeLoadModuleCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeLoadModuleCodeLength = 262;
static const JSC::Intrinsic s_moduleLoaderPrototypeLoadModuleCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeLoadModuleCode =
    "(function (moduleName, referrer)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var loader = this;\n" \
    "    return this.resolve(moduleName, referrer).then(function (key) {\n" \
    "        return loader.requestInstantiateAll(key);\n" \
    "    }).then(function (entry) {\n" \
    "        return entry.key;\n" \
    "    });\n" \
    "})\n" \
;

const JSC::ConstructAbility s_moduleLoaderPrototypeLinkAndEvaluateModuleCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_moduleLoaderPrototypeLinkAndEvaluateModuleCodeLength = 74;
static const JSC::Intrinsic s_moduleLoaderPrototypeLinkAndEvaluateModuleCodeIntrinsic = JSC::NoIntrinsic;
const char* s_moduleLoaderPrototypeLinkAndEvaluateModuleCode =
    "(function (key)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return this.requestReady(key);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_numberConstructorIsFiniteCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_numberConstructorIsFiniteCodeLength = 201;
static const JSC::Intrinsic s_numberConstructorIsFiniteCodeIntrinsic = JSC::NoIntrinsic;
const char* s_numberConstructorIsFiniteCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (typeof value !== \"number\")\n" \
    "        return false;\n" \
    "    if (value !== value)\n" \
    "        return false;\n" \
    "    return value !== @Infinity && value !== -@Infinity;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_numberConstructorIsNaNCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_numberConstructorIsNaNCodeLength = 69;
static const JSC::Intrinsic s_numberConstructorIsNaNCodeIntrinsic = JSC::NoIntrinsic;
const char* s_numberConstructorIsNaNCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return value !== value;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_numberPrototypeToLocaleStringCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_numberPrototypeToLocaleStringCodeLength = 193;
static const JSC::Intrinsic s_numberPrototypeToLocaleStringCodeIntrinsic = JSC::NoIntrinsic;
const char* s_numberPrototypeToLocaleStringCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var number = @thisNumberValue.@call(this);\n" \
    "    var numberFormat = new @NumberFormat(arguments[0], arguments[1]);\n" \
    "    return numberFormat.format(number);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_objectConstructorEnumerableOwnPropertiesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_objectConstructorEnumerableOwnPropertiesCodeLength = 731;
static const JSC::Intrinsic s_objectConstructorEnumerableOwnPropertiesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_objectConstructorEnumerableOwnPropertiesCode =
    "(function (object, kind)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    const obj = @Object(object);\n" \
    "    const ownKeys = @Reflect.@ownKeys(obj);\n" \
    "    const properties = [];\n" \
    "    for (let i = 0, keysLength = ownKeys.length; i < keysLength; ++i) {\n" \
    "        let nextKey = ownKeys[i];\n" \
    "        if (typeof nextKey === 'string') {\n" \
    "            let descriptor = @Reflect.@getOwnPropertyDescriptor(obj, nextKey);\n" \
    "            if (descriptor !== @undefined && descriptor.enumerable) {\n" \
    "                if (kind === @iterationKindValue)\n" \
    "                    properties.@push(obj[nextKey]);\n" \
    "                else if (kind === @iterationKindKeyValue)\n" \
    "                    properties.@push([nextKey, obj[nextKey]]);\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "    \n" \
    "    return properties;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_objectConstructorValuesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_objectConstructorValuesCodeLength = 239;
static const JSC::Intrinsic s_objectConstructorValuesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_objectConstructorValuesCode =
    "(function (object)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    \n" \
    "    if (object == null)\n" \
    "        throw new @TypeError(\"Object.values requires that input parameter not be null or undefined\");\n" \
    "    return @enumerableOwnProperties(object, @iterationKindValue);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_objectConstructorEntriesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_objectConstructorEntriesCodeLength = 248;
static const JSC::Intrinsic s_objectConstructorEntriesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_objectConstructorEntriesCode =
    "(function (object)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    \n" \
    "    if (object == null)\n" \
    "        throw new @TypeError(\"Object.entries requires that input parameter not be null or undefined\");\n" \
    "    \n" \
    "    return @enumerableOwnProperties(object, @iterationKindKeyValue);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_objectConstructorAssignCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_objectConstructorAssignCodeLength = 813;
static const JSC::Intrinsic s_objectConstructorAssignCodeIntrinsic = JSC::NoIntrinsic;
const char* s_objectConstructorAssignCode =
    "(function (target, sources)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (target == null)\n" \
    "        throw new @TypeError(\"can't convert \" + target + \" to object\");\n" \
    "    let objTarget = @Object(target);\n" \
    "    for (let s = 1, argumentsLength = arguments.length; s < argumentsLength; ++s) {\n" \
    "        let nextSource = arguments[s];\n" \
    "        if (nextSource != null) {\n" \
    "            let from = @Object(nextSource);\n" \
    "            let keys = @Reflect.@ownKeys(from);\n" \
    "            for (let i = 0, keysLength = keys.length; i < keysLength; ++i) {\n" \
    "                let nextKey = keys[i];\n" \
    "                let descriptor = @Reflect.@getOwnPropertyDescriptor(from, nextKey);\n" \
    "                if (descriptor !== @undefined && descriptor.enumerable)\n" \
    "                    objTarget[nextKey] = from[nextKey];\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "    return objTarget;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseConstructorAllCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseConstructorAllCodeLength = 1370;
static const JSC::Intrinsic s_promiseConstructorAllCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseConstructorAllCode =
    "(function (iterable)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isObject(this))\n" \
    "        throw new @TypeError(\"|this| is not a object\");\n" \
    "    var promiseCapability = @newPromiseCapability(this);\n" \
    "    var values = [];\n" \
    "    var index = 0;\n" \
    "    var remainingElementsCount = 1;\n" \
    "    function newResolveElement(index)\n" \
    "    {\n" \
    "        var alreadyCalled = false;\n" \
    "        return function (argument)\n" \
    "        {\n" \
    "            if (alreadyCalled)\n" \
    "                return @undefined;\n" \
    "            alreadyCalled = true;\n" \
    "            @putByValDirect(values, index, argument);\n" \
    "            --remainingElementsCount;\n" \
    "            if (remainingElementsCount === 0)\n" \
    "                return promiseCapability.@resolve.@call(@undefined, values);\n" \
    "            return @undefined;\n" \
    "        }\n" \
    "    }\n" \
    "    try {\n" \
    "        for (var value of iterable) {\n" \
    "            @putByValDirect(values, index, @undefined);\n" \
    "            var nextPromise = this.resolve(value);\n" \
    "            var resolveElement = newResolveElement(index);\n" \
    "            ++remainingElementsCount;\n" \
    "            nextPromise.then(resolveElement, promiseCapability.@reject);\n" \
    "            ++index;\n" \
    "        }\n" \
    "        --remainingElementsCount;\n" \
    "        if (remainingElementsCount === 0)\n" \
    "            promiseCapability.@resolve.@call(@undefined, values);\n" \
    "    } catch (error) {\n" \
    "        promiseCapability.@reject.@call(@undefined, error);\n" \
    "    }\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseConstructorRaceCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseConstructorRaceCodeLength = 504;
static const JSC::Intrinsic s_promiseConstructorRaceCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseConstructorRaceCode =
    "(function (iterable)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isObject(this))\n" \
    "        throw new @TypeError(\"|this| is not a object\");\n" \
    "    var promiseCapability = @newPromiseCapability(this);\n" \
    "    try {\n" \
    "        for (var value of iterable) {\n" \
    "            var nextPromise = this.resolve(value);\n" \
    "            nextPromise.then(promiseCapability.@resolve, promiseCapability.@reject);\n" \
    "        }\n" \
    "    } catch (error) {\n" \
    "        promiseCapability.@reject.@call(@undefined, error);\n" \
    "    }\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseConstructorRejectCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseConstructorRejectCodeLength = 277;
static const JSC::Intrinsic s_promiseConstructorRejectCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseConstructorRejectCode =
    "(function (reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isObject(this))\n" \
    "        throw new @TypeError(\"|this| is not a object\");\n" \
    "    var promiseCapability = @newPromiseCapability(this);\n" \
    "    promiseCapability.@reject.@call(@undefined, reason);\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseConstructorResolveCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseConstructorResolveCodeLength = 426;
static const JSC::Intrinsic s_promiseConstructorResolveCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseConstructorResolveCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isObject(this))\n" \
    "        throw new @TypeError(\"|this| is not a object\");\n" \
    "    if (@isPromise(value)) {\n" \
    "        var valueConstructor = value.constructor;\n" \
    "        if (valueConstructor === this)\n" \
    "            return value;\n" \
    "    }\n" \
    "    var promiseCapability = @newPromiseCapability(this);\n" \
    "    promiseCapability.@resolve.@call(@undefined, value);\n" \
    "    return promiseCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsIsPromiseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsIsPromiseCodeLength = 101;
static const JSC::Intrinsic s_promiseOperationsIsPromiseCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsIsPromiseCode =
    "(function (promise)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return @isObject(promise) && !!promise.@promiseState;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsNewPromiseReactionCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsNewPromiseReactionCodeLength = 136;
static const JSC::Intrinsic s_promiseOperationsNewPromiseReactionCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsNewPromiseReactionCode =
    "(function (capability, handler)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return {\n" \
    "        @capabilities: capability,\n" \
    "        @handler: handler\n" \
    "    };\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsNewPromiseCapabilityCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsNewPromiseCapabilityCodeLength = 1065;
static const JSC::Intrinsic s_promiseOperationsNewPromiseCapabilityCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsNewPromiseCapabilityCode =
    "(function (constructor)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (typeof constructor !== \"function\")\n" \
    "        throw new @TypeError(\"promise capability requires a constructor function\");\n" \
    "    var promiseCapability = {\n" \
    "        @promise: @undefined,\n" \
    "        @resolve: @undefined,\n" \
    "        @reject: @undefined\n" \
    "    };\n" \
    "    function executor(resolve, reject)\n" \
    "    {\n" \
    "        if (promiseCapability.@resolve !== @undefined)\n" \
    "            throw new @TypeError(\"resolve function is already set\");\n" \
    "        if (promiseCapability.@reject !== @undefined)\n" \
    "            throw new @TypeError(\"reject function is already set\");\n" \
    "        promiseCapability.@resolve = resolve;\n" \
    "        promiseCapability.@reject = reject;\n" \
    "    }\n" \
    "    var promise = new constructor(executor);\n" \
    "    if (typeof promiseCapability.@resolve !== \"function\")\n" \
    "        throw new @TypeError(\"executor did not take a resolve function\");\n" \
    "    if (typeof promiseCapability.@reject !== \"function\")\n" \
    "        throw new @TypeError(\"executor did not take a reject function\");\n" \
    "    promiseCapability.@promise = promise;\n" \
    "    return promiseCapability;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsTriggerPromiseReactionsCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsTriggerPromiseReactionsCodeLength = 203;
static const JSC::Intrinsic s_promiseOperationsTriggerPromiseReactionsCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsTriggerPromiseReactionsCode =
    "(function (reactions, argument)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    for (var index = 0, length = reactions.length; index < length; ++index)\n" \
    "        @enqueueJob(@promiseReactionJob, [reactions[index], argument]);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsRejectPromiseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsRejectPromiseCodeLength = 417;
static const JSC::Intrinsic s_promiseOperationsRejectPromiseCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsRejectPromiseCode =
    "(function (promise, reason)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var reactions = promise.@promiseRejectReactions;\n" \
    "    promise.@promiseResult = reason;\n" \
    "    promise.@promiseFulfillReactions = @undefined;\n" \
    "    promise.@promiseRejectReactions = @undefined;\n" \
    "    promise.@promiseState = @promiseStateRejected;\n" \
    "    @InspectorInstrumentation.promiseRejected(promise, reason, reactions);\n" \
    "    @triggerPromiseReactions(reactions, reason);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsFulfillPromiseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsFulfillPromiseCodeLength = 416;
static const JSC::Intrinsic s_promiseOperationsFulfillPromiseCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsFulfillPromiseCode =
    "(function (promise, value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var reactions = promise.@promiseFulfillReactions;\n" \
    "    promise.@promiseResult = value;\n" \
    "    promise.@promiseFulfillReactions = @undefined;\n" \
    "    promise.@promiseRejectReactions = @undefined;\n" \
    "    promise.@promiseState = @promiseStateFulfilled;\n" \
    "    @InspectorInstrumentation.promiseFulfilled(promise, value, reactions);\n" \
    "    @triggerPromiseReactions(reactions, value);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsCreateResolvingFunctionsCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsCreateResolvingFunctionsCodeLength = 1051;
static const JSC::Intrinsic s_promiseOperationsCreateResolvingFunctionsCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsCreateResolvingFunctionsCode =
    "(function (promise)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var alreadyResolved = false;\n" \
    "    var resolve = function (resolution) {\n" \
    "        if (alreadyResolved)\n" \
    "            return @undefined;\n" \
    "        alreadyResolved = true;\n" \
    "        if (resolution === promise)\n" \
    "            return @rejectPromise(promise, new @TypeError(\"Resolve a promise with itself\"));\n" \
    "        if (!@isObject(resolution))\n" \
    "            return @fulfillPromise(promise, resolution);\n" \
    "        var then;\n" \
    "        try {\n" \
    "            then = resolution.then;\n" \
    "        } catch (error) {\n" \
    "            return @rejectPromise(promise, error);\n" \
    "        }\n" \
    "        if (typeof then !== 'function')\n" \
    "            return @fulfillPromise(promise, resolution);\n" \
    "        @enqueueJob(@promiseResolveThenableJob, [promise, resolution, then]);\n" \
    "        return @undefined;\n" \
    "    };\n" \
    "    var reject = function (reason) {\n" \
    "        if (alreadyResolved)\n" \
    "            return @undefined;\n" \
    "        alreadyResolved = true;\n" \
    "        return @rejectPromise(promise, reason);\n" \
    "    };\n" \
    "    return {\n" \
    "        @resolve: resolve,\n" \
    "        @reject: reject\n" \
    "    };\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsPromiseReactionJobCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsPromiseReactionJobCodeLength = 356;
static const JSC::Intrinsic s_promiseOperationsPromiseReactionJobCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsPromiseReactionJobCode =
    "(function (reaction, argument)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var promiseCapability = reaction.@capabilities;\n" \
    "    var result;\n" \
    "    try {\n" \
    "        result = reaction.@handler.@call(@undefined, argument);\n" \
    "    } catch (error) {\n" \
    "        return promiseCapability.@reject.@call(@undefined, error);\n" \
    "    }\n" \
    "    return promiseCapability.@resolve.@call(@undefined, result);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsPromiseResolveThenableJobCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsPromiseResolveThenableJobCodeLength = 342;
static const JSC::Intrinsic s_promiseOperationsPromiseResolveThenableJobCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsPromiseResolveThenableJobCode =
    "(function (promiseToResolve, thenable, then)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var resolvingFunctions = @createResolvingFunctions(promiseToResolve);\n" \
    "    try {\n" \
    "        return then.@call(thenable, resolvingFunctions.@resolve, resolvingFunctions.@reject);\n" \
    "    } catch (error) {\n" \
    "        return resolvingFunctions.@reject.@call(@undefined, error);\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promiseOperationsInitializePromiseCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promiseOperationsInitializePromiseCodeLength = 549;
static const JSC::Intrinsic s_promiseOperationsInitializePromiseCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promiseOperationsInitializePromiseCode =
    "(function (executor)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (typeof executor !== 'function')\n" \
    "        throw new @TypeError(\"Promise constructor takes a function argument\");\n" \
    "    this.@promiseState = @promiseStatePending;\n" \
    "    this.@promiseFulfillReactions = [];\n" \
    "    this.@promiseRejectReactions = [];\n" \
    "    var resolvingFunctions = @createResolvingFunctions(this);\n" \
    "    try {\n" \
    "        executor(resolvingFunctions.@resolve, resolvingFunctions.@reject);\n" \
    "    } catch (error) {\n" \
    "        return resolvingFunctions.@reject.@call(@undefined, error);\n" \
    "    }\n" \
    "    return this;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promisePrototypeCatchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promisePrototypeCatchCodeLength = 92;
static const JSC::Intrinsic s_promisePrototypeCatchCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promisePrototypeCatchCode =
    "(function (onRejected)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return this.then(@undefined, onRejected);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_promisePrototypeThenCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_promisePrototypeThenCodeLength = 1220;
static const JSC::Intrinsic s_promisePrototypeThenCodeIntrinsic = JSC::NoIntrinsic;
const char* s_promisePrototypeThenCode =
    "(function (onFulfilled, onRejected)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isPromise(this))\n" \
    "        throw new @TypeError(\"|this| is not a object\");\n" \
    "    var constructor = @speciesConstructor(this, @Promise);\n" \
    "    var resultCapability = @newPromiseCapability(constructor);\n" \
    "    if (typeof onFulfilled !== \"function\")\n" \
    "        onFulfilled = function (argument) { return argument; };\n" \
    "    if (typeof onRejected !== \"function\")\n" \
    "        onRejected = function (argument) { throw argument; };\n" \
    "    var fulfillReaction = @newPromiseReaction(resultCapability, onFulfilled);\n" \
    "    var rejectReaction = @newPromiseReaction(resultCapability, onRejected);\n" \
    "    var state = this.@promiseState;\n" \
    "    if (state === @promiseStatePending) {\n" \
    "        @putByValDirect(this.@promiseFulfillReactions, this.@promiseFulfillReactions.length, fulfillReaction)\n" \
    "        @putByValDirect(this.@promiseRejectReactions, this.@promiseRejectReactions.length, rejectReaction)\n" \
    "    } else if (state === @promiseStateFulfilled)\n" \
    "        @enqueueJob(@promiseReactionJob, [fulfillReaction, this.@promiseResult]);\n" \
    "    else if (state === @promiseStateRejected)\n" \
    "        @enqueueJob(@promiseReactionJob, [rejectReaction, this.@promiseResult]);\n" \
    "    return resultCapability.@promise;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_reflectObjectApplyCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_reflectObjectApplyCodeLength = 376;
static const JSC::Intrinsic s_reflectObjectApplyCodeIntrinsic = JSC::NoIntrinsic;
const char* s_reflectObjectApplyCode =
    "(function (target, thisArgument, argumentsList)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (typeof target !== \"function\")\n" \
    "        throw new @TypeError(\"Reflect.apply requires the first argument be a function\");\n" \
    "    if (!@isObject(argumentsList))\n" \
    "        throw new @TypeError(\"Reflect.apply requires the third argument be an object\");\n" \
    "    return target.@apply(thisArgument, argumentsList);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_reflectObjectDeletePropertyCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_reflectObjectDeletePropertyCodeLength = 201;
static const JSC::Intrinsic s_reflectObjectDeletePropertyCodeIntrinsic = JSC::NoIntrinsic;
const char* s_reflectObjectDeletePropertyCode =
    "(function (target, propertyKey)\n" \
    "{\n" \
    "    if (!@isObject(target))\n" \
    "        throw new @TypeError(\"Reflect.deleteProperty requires the first argument be an object\");\n" \
    "    return delete target[propertyKey];\n" \
    "})\n" \
;

const JSC::ConstructAbility s_reflectObjectHasCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_reflectObjectHasCodeLength = 203;
static const JSC::Intrinsic s_reflectObjectHasCodeIntrinsic = JSC::NoIntrinsic;
const char* s_reflectObjectHasCode =
    "(function (target, propertyKey)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isObject(target))\n" \
    "        throw new @TypeError(\"Reflect.has requires the first argument be an object\");\n" \
    "    return propertyKey in target;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeAdvanceStringIndexCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeAdvanceStringIndexCodeLength = 415;
static const JSC::Intrinsic s_regExpPrototypeAdvanceStringIndexCodeIntrinsic = JSC::NoIntrinsic;
const char* s_regExpPrototypeAdvanceStringIndexCode =
    "(function (string, index, unicode)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!unicode)\n" \
    "        return index + 1;\n" \
    "    if (index + 1 >= string.length)\n" \
    "        return index + 1;\n" \
    "    let first = string.@charCodeAt(index);\n" \
    "    if (first < 0xD800 || first > 0xDBFF)\n" \
    "        return index + 1;\n" \
    "    let second = string.@charCodeAt(index + 1);\n" \
    "    if (second < 0xDC00 || second > 0xDFFF)\n" \
    "        return index + 1;\n" \
    "    return index + 2;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeRegExpExecCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeRegExpExecCodeLength = 439;
static const JSC::Intrinsic s_regExpPrototypeRegExpExecCodeIntrinsic = JSC::NoIntrinsic;
const char* s_regExpPrototypeRegExpExecCode =
    "(function (regexp, str)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let exec = regexp.exec;\n" \
    "    let builtinExec = @regExpBuiltinExec;\n" \
    "    if (exec !== builtinExec && typeof exec === \"function\") {\n" \
    "        let result = exec.@call(regexp, str);\n" \
    "        if (result !== null && !@isObject(result))\n" \
    "            throw new @TypeError(\"The result of a RegExp exec must be null or an object\");\n" \
    "        return result;\n" \
    "    }\n" \
    "    return builtinExec.@call(regexp, str);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeHasObservableSideEffectsForRegExpMatchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeHasObservableSideEffectsForRegExpMatchCodeLength = 431;
static const JSC::Intrinsic s_regExpPrototypeHasObservableSideEffectsForRegExpMatchCodeIntrinsic = JSC::NoIntrinsic;
const char* s_regExpPrototypeHasObservableSideEffectsForRegExpMatchCode =
    "(function (regexp) {\n" \
    "    let regexpExec = @tryGetById(regexp, \"exec\");\n" \
    "    if (regexpExec !== @regExpBuiltinExec)\n" \
    "        return true;\n" \
    "    let regexpGlobal = @tryGetById(regexp, \"global\");\n" \
    "    if (regexpGlobal !== @regExpProtoGlobalGetter)\n" \
    "        return true;\n" \
    "    let regexpUnicode = @tryGetById(regexp, \"unicode\");\n" \
    "    if (regexpUnicode !== @regExpProtoUnicodeGetter)\n" \
    "        return true;\n" \
    "    return !@isRegExpObject(regexp);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeMatchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeMatchCodeLength = 1217;
static const JSC::Intrinsic s_regExpPrototypeMatchCodeIntrinsic = JSC::NoIntrinsic;
const char* s_regExpPrototypeMatchCode =
    "(function (strArg)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isObject(this))\n" \
    "        throw new @TypeError(\"RegExp.prototype.@@match requires that |this| be an Object\");\n" \
    "    let regexp = this;\n" \
    "    if (!@hasObservableSideEffectsForRegExpMatch(regexp))\n" \
    "        return @regExpMatchFast.@call(regexp, strArg);\n" \
    "    let str = @toString(strArg);\n" \
    "    if (!regexp.global)\n" \
    "        return @regExpExec(regexp, str);\n" \
    "    \n" \
    "    let unicode = regexp.unicode;\n" \
    "    regexp.lastIndex = 0;\n" \
    "    let resultList = [];\n" \
    "    const maximumReasonableMatchSize = 100000000;\n" \
    "    while (true) {\n" \
    "        let result = @regExpExec(regexp, str);\n" \
    "        \n" \
    "        if (result === null) {\n" \
    "            if (resultList.length === 0)\n" \
    "                return null;\n" \
    "            return resultList;\n" \
    "        }\n" \
    "        if (resultList.length > maximumReasonableMatchSize)\n" \
    "            throw new @Error(\"Out of memory\");\n" \
    "        if (!@isObject(result))\n" \
    "            throw new @TypeError(\"RegExp.prototype.@@match call to RegExp.exec didn't return null or an object\");\n" \
    "        let resultString = @toString(result[0]);\n" \
    "        if (!resultString.length)\n" \
    "            regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);\n" \
    "        resultList.@push(resultString);\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeReplaceCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeReplaceCodeLength = 5221;
static const JSC::Intrinsic s_regExpPrototypeReplaceCodeIntrinsic = JSC::NoIntrinsic;
const char* s_regExpPrototypeReplaceCode =
    "(function (strArg, replace)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    function getSubstitution(matched, str, position, captures, replacement)\n" \
    "    {\n" \
    "        \"use strict\";\n" \
    "        let matchLength = matched.length;\n" \
    "        let stringLength = str.length;\n" \
    "        let tailPos = position + matchLength;\n" \
    "        let m = captures.length;\n" \
    "        let replacementLength = replacement.length;\n" \
    "        let result = \"\";\n" \
    "        let lastStart = 0;\n" \
    "        for (let start = 0; start = replacement.indexOf(\"$\", lastStart), start !== -1; lastStart = start) {\n" \
    "            if (start - lastStart > 0)\n" \
    "                result = result + replacement.substring(lastStart, start);\n" \
    "            start++;\n" \
    "            let ch = replacement.charAt(start);\n" \
    "            if (ch === \"\")\n" \
    "                result = result + \"$\";\n" \
    "            else {\n" \
    "                switch (ch)\n" \
    "                {\n" \
    "                case \"$\":\n" \
    "                    result = result + \"$\";\n" \
    "                    start++;\n" \
    "                    break;\n" \
    "                case \"&\":\n" \
    "                    result = result + matched;\n" \
    "                    start++;\n" \
    "                    break;\n" \
    "                case \"`\":\n" \
    "                    if (position > 0)\n" \
    "                        result = result + str.substring(0, position);\n" \
    "                    start++;\n" \
    "                    break;\n" \
    "                case \"'\":\n" \
    "                    if (tailPos < stringLength)\n" \
    "                        result = result + str.substring(tailPos);\n" \
    "                    start++;\n" \
    "                    break;\n" \
    "                default:\n" \
    "                    let chCode = ch.charCodeAt(0);\n" \
    "                    if (chCode >= 0x30 && chCode <= 0x39) {\n" \
    "                        start++;\n" \
    "                        let n = chCode - 0x30;\n" \
    "                        if (n > m)\n" \
    "                            break;\n" \
    "                        if (start < replacementLength) {\n" \
    "                            let nextChCode = replacement.charCodeAt(start);\n" \
    "                            if (nextChCode >= 0x30 && nextChCode <= 0x39) {\n" \
    "                                let nn = 10 * n + nextChCode - 0x30;\n" \
    "                                if (nn <= m) {\n" \
    "                                    n = nn;\n" \
    "                                    start++;\n" \
    "                                }\n" \
    "                            }\n" \
    "                        }\n" \
    "                        if (n == 0)\n" \
    "                            break;\n" \
    "                        if (captures[n] != @undefined)\n" \
    "                            result = result + captures[n];\n" \
    "                    } else\n" \
    "                        result = result + \"$\";\n" \
    "                    break;\n" \
    "                }\n" \
    "            }\n" \
    "        }\n" \
    "        return result + replacement.substring(lastStart);\n" \
    "    }\n" \
    "    if (!@isObject(this))\n" \
    "        throw new @TypeError(\"RegExp.prototype.@@replace requires that |this| be an Object\");\n" \
    "    let regexp = this;\n" \
    "    let str = @toString(strArg);\n" \
    "    let stringLength = str.length;\n" \
    "    let functionalReplace = typeof replace === 'function';\n" \
    "    if (!functionalReplace)\n" \
    "        replace = @toString(replace);\n" \
    "    let global = regexp.global;\n" \
    "    let unicode = false;\n" \
    "    if (global) {\n" \
    "        unicode = regexp.unicode;\n" \
    "        regexp.lastIndex = 0;\n" \
    "    }\n" \
    "    let resultList = [];\n" \
    "    let result;\n" \
    "    let done = false;\n" \
    "    while (!done) {\n" \
    "        result = @regExpExec(regexp, str);\n" \
    "        if (result === null)\n" \
    "            done = true;\n" \
    "        else {\n" \
    "            resultList.@push(result);\n" \
    "            if (!global)\n" \
    "                done = true;\n" \
    "            else {\n" \
    "                let matchStr = @toString(result[0]);\n" \
    "                if (!matchStr.length)\n" \
    "                    regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "    let accumulatedResult = \"\";\n" \
    "    let nextSourcePosition = 0;\n" \
    "    let lastPosition = 0;\n" \
    "    for (result of resultList) {\n" \
    "        let nCaptures = result.length - 1;\n" \
    "        if (nCaptures < 0)\n" \
    "            nCaptures = 0;\n" \
    "        let matched = @toString(result[0]);\n" \
    "        let matchLength = matched.length;\n" \
    "        let position = result.index;\n" \
    "        position = (position > stringLength) ? stringLength : position;\n" \
    "        position = (position < 0) ? 0 : position;\n" \
    "        let captures = [];\n" \
    "        for (let n = 1; n <= nCaptures; n++) {\n" \
    "            let capN = result[n];\n" \
    "            if (capN !== @undefined)\n" \
    "                capN = @toString(capN);\n" \
    "            captures[n] = capN;\n" \
    "        }\n" \
    "        let replacement;\n" \
    "        if (functionalReplace) {\n" \
    "            let replacerArgs = [ matched ].concat(captures.slice(1));\n" \
    "            replacerArgs.@push(position);\n" \
    "            replacerArgs.@push(str);\n" \
    "            let replValue = replace.@apply(@undefined, replacerArgs);\n" \
    "            replacement = @toString(replValue);\n" \
    "        } else\n" \
    "            replacement = getSubstitution(matched, str, position, captures, replace);\n" \
    "        if (position >= nextSourcePosition && position >= lastPosition) {\n" \
    "            accumulatedResult = accumulatedResult + str.substring(nextSourcePosition, position) + replacement;\n" \
    "            nextSourcePosition = position + matchLength;\n" \
    "            lastPosition = position;\n" \
    "        }\n" \
    "    }\n" \
    "    if (nextSourcePosition >= stringLength)\n" \
    "        return  accumulatedResult;\n" \
    "    return accumulatedResult + str.substring(nextSourcePosition);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeSearchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeSearchCodeLength = 585;
static const JSC::Intrinsic s_regExpPrototypeSearchCodeIntrinsic = JSC::NoIntrinsic;
const char* s_regExpPrototypeSearchCode =
    "(function (strArg)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let regexp = this;\n" \
    "    if (@isRegExpObject(regexp) && @tryGetById(regexp, \"exec\") === @regExpBuiltinExec)\n" \
    "        return @regExpSearchFast.@call(regexp, strArg);\n" \
    "    if (!@isObject(this))\n" \
    "        throw new @TypeError(\"RegExp.prototype.@@search requires that |this| be an Object\");\n" \
    "    let str = @toString(strArg)\n" \
    "    let previousLastIndex = regexp.lastIndex;\n" \
    "    regexp.lastIndex = 0;\n" \
    "    let result = @regExpExec(regexp, str);\n" \
    "    regexp.lastIndex = previousLastIndex;\n" \
    "    if (result === null)\n" \
    "        return -1;\n" \
    "    return result.index;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeHasObservableSideEffectsForRegExpSplitCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeHasObservableSideEffectsForRegExpSplitCodeLength = 1090;
static const JSC::Intrinsic s_regExpPrototypeHasObservableSideEffectsForRegExpSplitCodeIntrinsic = JSC::NoIntrinsic;
const char* s_regExpPrototypeHasObservableSideEffectsForRegExpSplitCode =
    "(function (regexp) {\n" \
    "    let regexpExec = @tryGetById(regexp, \"exec\");\n" \
    "    if (regexpExec !== @regExpBuiltinExec)\n" \
    "        return true;\n" \
    "    let regexpFlags = @tryGetById(regexp, \"flags\");\n" \
    "    if (regexpFlags !== @regExpProtoFlagsGetter)\n" \
    "        return true;\n" \
    "    let regexpGlobal = @tryGetById(regexp, \"global\");\n" \
    "    if (regexpGlobal !== @regExpProtoGlobalGetter)\n" \
    "        return true;\n" \
    "    let regexpIgnoreCase = @tryGetById(regexp, \"ignoreCase\");\n" \
    "    if (regexpIgnoreCase !== @regExpProtoIgnoreCaseGetter)\n" \
    "        return true;\n" \
    "    let regexpMultiline = @tryGetById(regexp, \"multiline\");\n" \
    "    if (regexpMultiline !== @regExpProtoMultilineGetter)\n" \
    "        return true;\n" \
    "    let regexpSticky = @tryGetById(regexp, \"sticky\");\n" \
    "    if (regexpSticky !== @regExpProtoStickyGetter)\n" \
    "        return true;\n" \
    "    let regexpUnicode = @tryGetById(regexp, \"unicode\");\n" \
    "    if (regexpUnicode !== @regExpProtoUnicodeGetter)\n" \
    "        return true;\n" \
    "    let regexpSource = @tryGetById(regexp, \"source\");\n" \
    "    if (regexpSource !== @regExpProtoSourceGetter)\n" \
    "        return true;\n" \
    "    \n" \
    "    return !@isRegExpObject(regexp);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeSplitCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeSplitCodeLength = 2655;
static const JSC::Intrinsic s_regExpPrototypeSplitCodeIntrinsic = JSC::NoIntrinsic;
const char* s_regExpPrototypeSplitCode =
    "(function (string, limit)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isObject(this))\n" \
    "        throw new @TypeError(\"RegExp.prototype.@@split requires that |this| be an Object\");\n" \
    "    let regexp = this;\n" \
    "    let str = @toString(string);\n" \
    "    let speciesConstructor = @speciesConstructor(regexp, @RegExp);\n" \
    "    if (speciesConstructor === @RegExp && !@hasObservableSideEffectsForRegExpSplit(regexp))\n" \
    "        return @regExpSplitFast.@call(regexp, str, limit);\n" \
    "    let flags = @toString(regexp.flags);\n" \
    "    let unicodeMatching = @stringIncludesInternal.@call(flags, \"u\");\n" \
    "    let newFlags = @stringIncludesInternal.@call(flags, \"y\") ? flags : flags + \"y\";\n" \
    "    let splitter = new speciesConstructor(regexp, newFlags);\n" \
    "    if (!@hasObservableSideEffectsForRegExpSplit(splitter))\n" \
    "        return @regExpSplitFast.@call(splitter, str, limit);\n" \
    "    let result = [];\n" \
    "    limit = (limit === @undefined) ? 0xffffffff : limit >>> 0;\n" \
    "    if (!limit)\n" \
    "        return result;\n" \
    "    let size = str.length;\n" \
    "    if (!size) {\n" \
    "        let z = @regExpExec(splitter, str);\n" \
    "        if (z != null)\n" \
    "            return result;\n" \
    "        @putByValDirect(result, 0, str);\n" \
    "        return result;\n" \
    "    }\n" \
    "    let position = 0;\n" \
    "    let matchPosition = 0;\n" \
    "    while (matchPosition < size) {\n" \
    "        splitter.lastIndex = matchPosition;\n" \
    "        let matches = @regExpExec(splitter, str);\n" \
    "        if (matches === null)\n" \
    "            matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);\n" \
    "        else {\n" \
    "            let endPosition = @toLength(splitter.lastIndex);\n" \
    "            endPosition = (endPosition <= size) ? endPosition : size;\n" \
    "            if (endPosition === position)\n" \
    "                matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);\n" \
    "            else {\n" \
    "                let subStr = @stringSubstrInternal.@call(str, position, matchPosition - position);\n" \
    "                @putByValDirect(result, result.length, subStr);\n" \
    "                if (result.length == limit)\n" \
    "                    return result;\n" \
    "                position = endPosition;\n" \
    "                let numberOfCaptures = matches.length > 1 ? matches.length - 1 : 0;\n" \
    "                let i = 1;\n" \
    "                while (i <= numberOfCaptures) {\n" \
    "                    let nextCapture = matches[i];\n" \
    "                    @putByValDirect(result, result.length, nextCapture);\n" \
    "                    if (result.length == limit)\n" \
    "                        return result;\n" \
    "                    i++;\n" \
    "                }\n" \
    "                matchPosition = position;\n" \
    "            }\n" \
    "        }\n" \
    "    }\n" \
    "    let remainingStr = @stringSubstrInternal.@call(str, position, size);\n" \
    "    @putByValDirect(result, result.length, remainingStr);\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_regExpPrototypeTestCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_regExpPrototypeTestCodeLength = 461;
static const JSC::Intrinsic s_regExpPrototypeTestCodeIntrinsic = JSC::RegExpTestIntrinsic;
const char* s_regExpPrototypeTestCode =
    "(function (strArg)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let regexp = this;\n" \
    "    if (@isRegExpObject(regexp) && @tryGetById(regexp, \"exec\") === @regExpBuiltinExec)\n" \
    "        return @regExpTestFast.@call(regexp, strArg);\n" \
    "    if (!@isObject(regexp))\n" \
    "        throw new @TypeError(\"RegExp.prototype.test requires that |this| be an Object\");\n" \
    "    let str = @toString(strArg);\n" \
    "    let match = @regExpExec(regexp, str);\n" \
    "    if (match !== null)\n" \
    "        return true;\n" \
    "    return false;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_setPrototypeForEachCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_setPrototypeForEachCodeLength = 554;
static const JSC::Intrinsic s_setPrototypeForEachCodeIntrinsic = JSC::NoIntrinsic;
const char* s_setPrototypeForEachCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isSet(this))\n" \
    "        throw new @TypeError(\"Set operation called on non-Set object\");\n" \
    "    if (typeof callback !== 'function')\n" \
    "        throw new @TypeError(\"Set.prototype.forEach callback must be a function\");\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    var iterator = @SetIterator(this);\n" \
    "    var value = [ @undefined ];\n" \
    "    for (;;) {\n" \
    "        if (@setIteratorNext.@call(iterator, value))\n" \
    "            break;\n" \
    "        callback.@call(thisArg, value[0], value[0], this);\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringConstructorRawCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringConstructorRawCodeLength = 1045;
static const JSC::Intrinsic s_stringConstructorRawCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringConstructorRawCode =
    "(function (template)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (template === null || template === @undefined)\n" \
    "        throw new @TypeError(\"String.raw requires template not be null or undefined\");\n" \
    "    var cookedSegments = @Object(template);\n" \
    "    var rawValue = cookedSegments.raw;\n" \
    "    if (rawValue === null || rawValue === @undefined)\n" \
    "        throw new @TypeError(\"String.raw requires template.raw not be null or undefined\");\n" \
    "    var rawSegments = @Object(rawValue);\n" \
    "    var numberOfSubstitutions = arguments.length - 1;\n" \
    "    var segmentCount = @toLength(rawSegments.length);\n" \
    "    if (segmentCount <= 0)\n" \
    "        return '';\n" \
    "    var stringElements = '';\n" \
    "    for (var i = 0; ; ++i) {\n" \
    "        var segment = @toString(rawSegments[i]);\n" \
    "        stringElements += segment;\n" \
    "        if ((i + 1) === segmentCount)\n" \
    "            return stringElements;\n" \
    "        if (i < numberOfSubstitutions) {\n" \
    "            var substitutionIndexInArguments = i + 1;\n" \
    "            var next = @toString(arguments[substitutionIndexInArguments]);\n" \
    "            stringElements += next;\n" \
    "        }\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringIteratorPrototypeNextCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringIteratorPrototypeNextCodeLength = 1225;
static const JSC::Intrinsic s_stringIteratorPrototypeNextCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringIteratorPrototypeNextCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"%StringIteratorPrototype%.next requires that |this| not be null or undefined\");\n" \
    "    var position = this.@stringIteratorNextIndex;\n" \
    "    if (position === @undefined)\n" \
    "        throw new @TypeError(\"%StringIteratorPrototype%.next requires that |this| be a String Iterator instance\");\n" \
    "    var done = true;\n" \
    "    var value = @undefined;\n" \
    "    var string = this.@iteratedString;\n" \
    "    if (string !== @undefined) {\n" \
    "        var length = string.length >>> 0;\n" \
    "        if (position >= length) {\n" \
    "            this.@iteratedString = @undefined;\n" \
    "        } else {\n" \
    "            done = false;\n" \
    "            var first = string.@charCodeAt(position);\n" \
    "            if (first < 0xD800 || first > 0xDBFF || position + 1 === length)\n" \
    "                value = string[position];\n" \
    "            else {\n" \
    "                var second = string.@charCodeAt(position + 1);\n" \
    "                if (second < 0xDC00 || second > 0xDFFF)\n" \
    "                    value = string[position];\n" \
    "                else\n" \
    "                    value = string[position] + string[position + 1];\n" \
    "            }\n" \
    "            this.@stringIteratorNextIndex = position + value.length;\n" \
    "        }\n" \
    "    }\n" \
    "    return {done, value};\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeMatchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeMatchCodeLength = 472;
static const JSC::Intrinsic s_stringPrototypeMatchCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypeMatchCode =
    "(function (regexp)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"String.prototype.match requires that |this| not be null or undefined\");\n" \
    "    if (regexp != null) {\n" \
    "        var matcher = regexp.@matchSymbol;\n" \
    "        if (matcher != @undefined)\n" \
    "            return matcher.@call(regexp, this);\n" \
    "    }\n" \
    "    let thisString = @toString(this);\n" \
    "    let createdRegExp = @regExpCreate(regexp, @undefined);\n" \
    "    return createdRegExp.@matchSymbol(thisString);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeRepeatSlowPathCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeRepeatSlowPathCodeLength = 473;
static const JSC::Intrinsic s_stringPrototypeRepeatSlowPathCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypeRepeatSlowPathCode =
    "(function (string, count)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (count === 0 || string.length === 0)\n" \
    "        return \"\";\n" \
    "    if (count === 1)\n" \
    "        return string;\n" \
    "    if (string.length * count > @MAX_STRING_LENGTH)\n" \
    "        throw new @Error(\"Out of memory\");\n" \
    "    var result = \"\";\n" \
    "    var operand = string;\n" \
    "    while (true) {\n" \
    "        if (count & 1)\n" \
    "            result += operand;\n" \
    "        count >>= 1;\n" \
    "        if (!count)\n" \
    "            return result;\n" \
    "        operand += operand;\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeRepeatCharactersSlowPathCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeRepeatCharactersSlowPathCodeLength = 526;
static const JSC::Intrinsic s_stringPrototypeRepeatCharactersSlowPathCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypeRepeatCharactersSlowPathCode =
    "(function (string, count)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var repeatCount = (count / string.length) | 0;\n" \
    "    var remainingCharacters = count - repeatCount * string.length;\n" \
    "    var result = \"\";\n" \
    "    var operand = string;\n" \
    "    while (true) {\n" \
    "        if (repeatCount & 1)\n" \
    "            result += operand;\n" \
    "        repeatCount >>= 1;\n" \
    "        if (!repeatCount)\n" \
    "            break;\n" \
    "        operand += operand;\n" \
    "    }\n" \
    "    if (remainingCharacters)\n" \
    "        result += @stringSubstrInternal.@call(string, 0, remainingCharacters);\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeRepeatCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeRepeatCodeLength = 585;
static const JSC::Intrinsic s_stringPrototypeRepeatCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypeRepeatCode =
    "(function (count)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"String.prototype.repeat requires that |this| not be null or undefined\");\n" \
    "    var string = @toString(this);\n" \
    "    count = @toInteger(count);\n" \
    "    if (count < 0 || count === @Infinity)\n" \
    "        throw new @RangeError(\"String.prototype.repeat argument must be greater than or equal to 0 and not be Infinity\");\n" \
    "    if (string.length === 1) {\n" \
    "        var result = @repeatCharacter(string, count);\n" \
    "        if (result !== null)\n" \
    "            return result;\n" \
    "    }\n" \
    "    return @repeatSlowPath(string, count);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypePadStartCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypePadStartCodeLength = 950;
static const JSC::Intrinsic s_stringPrototypePadStartCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypePadStartCode =
    "(function (maxLength)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"String.prototype.padStart requires that |this| not be null or undefined\");\n" \
    "    var string = @toString(this);\n" \
    "    maxLength = @toLength(maxLength);\n" \
    "    var stringLength = string.length;\n" \
    "    if (maxLength <= stringLength)\n" \
    "        return string;\n" \
    "    var filler;\n" \
    "    var fillString = arguments[1];\n" \
    "    if (fillString === @undefined)\n" \
    "        filler = \" \";\n" \
    "    else {\n" \
    "        filler = @toString(fillString);\n" \
    "        if (filler === \"\")\n" \
    "            return string;\n" \
    "    }\n" \
    "    if (maxLength > @MAX_STRING_LENGTH)\n" \
    "        throw new @Error(\"Out of memory\");\n" \
    "    var fillLength = maxLength - stringLength;\n" \
    "    var truncatedStringFiller;\n" \
    "    if (filler.length === 1)\n" \
    "        truncatedStringFiller = @repeatCharacter(filler, fillLength);\n" \
    "    else\n" \
    "        truncatedStringFiller = @repeatCharactersSlowPath(filler, fillLength);\n" \
    "    return truncatedStringFiller + string;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypePadEndCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypePadEndCodeLength = 948;
static const JSC::Intrinsic s_stringPrototypePadEndCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypePadEndCode =
    "(function (maxLength)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"String.prototype.padEnd requires that |this| not be null or undefined\");\n" \
    "    var string = @toString(this);\n" \
    "    maxLength = @toLength(maxLength);\n" \
    "    var stringLength = string.length;\n" \
    "    if (maxLength <= stringLength)\n" \
    "        return string;\n" \
    "    var filler;\n" \
    "    var fillString = arguments[1];\n" \
    "    if (fillString === @undefined)\n" \
    "        filler = \" \";\n" \
    "    else {\n" \
    "        filler = @toString(fillString);\n" \
    "        if (filler === \"\")\n" \
    "            return string;\n" \
    "    }\n" \
    "    if (maxLength > @MAX_STRING_LENGTH)\n" \
    "        throw new @Error(\"Out of memory\");\n" \
    "    var fillLength = maxLength - stringLength;\n" \
    "    var truncatedStringFiller;\n" \
    "    if (filler.length === 1)\n" \
    "        truncatedStringFiller = @repeatCharacter(filler, fillLength);\n" \
    "    else\n" \
    "        truncatedStringFiller = @repeatCharactersSlowPath(filler, fillLength);\n" \
    "    return string + truncatedStringFiller;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeHasObservableSideEffectsForStringReplaceCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeHasObservableSideEffectsForStringReplaceCodeLength = 519;
static const JSC::Intrinsic s_stringPrototypeHasObservableSideEffectsForStringReplaceCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypeHasObservableSideEffectsForStringReplaceCode =
    "(function (regexp, replacer) {\n" \
    "    if (replacer !== @regExpPrototypeSymbolReplace)\n" \
    "        return true;\n" \
    "    \n" \
    "    let regexpExec = @tryGetById(regexp, \"exec\");\n" \
    "    if (regexpExec !== @regExpBuiltinExec)\n" \
    "        return true;\n" \
    "    let regexpGlobal = @tryGetById(regexp, \"global\");\n" \
    "    if (regexpGlobal !== @regExpProtoGlobalGetter)\n" \
    "        return true;\n" \
    "    let regexpUnicode = @tryGetById(regexp, \"unicode\");\n" \
    "    if (regexpUnicode !== @regExpProtoUnicodeGetter)\n" \
    "        return true;\n" \
    "    return !@isRegExpObject(regexp);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeReplaceCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeReplaceCodeLength = 669;
static const JSC::Intrinsic s_stringPrototypeReplaceCodeIntrinsic = JSC::StringPrototypeReplaceIntrinsic;
const char* s_stringPrototypeReplaceCode =
    "(function (search, replace)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"String.prototype.replace requires that |this| not be null or undefined\");\n" \
    "    if (search != null) {\n" \
    "        let replacer = search.@replaceSymbol;\n" \
    "        if (replacer !== @undefined) {\n" \
    "            if (!@hasObservableSideEffectsForStringReplace(search, replacer))\n" \
    "                return @toString(this).@replaceUsingRegExp(search, replace);\n" \
    "            return replacer.@call(search, this, replace);\n" \
    "        }\n" \
    "    }\n" \
    "    let thisString = @toString(this);\n" \
    "    let searchString = @toString(search);\n" \
    "    return thisString.@replaceUsingStringSearch(searchString, replace);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeLocaleCompareCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeLocaleCompareCodeLength = 499;
static const JSC::Intrinsic s_stringPrototypeLocaleCompareCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypeLocaleCompareCode =
    "(function (that)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"String.prototype.localeCompare requires that |this| not be null or undefined\");\n" \
    "    var thisString = @toString(this);\n" \
    "    var thatString = @toString(that);\n" \
    "    if (arguments[1] === @undefined && arguments[2] === @undefined)\n" \
    "        return @Collator.prototype.compare(thisString, thatString);\n" \
    "    var collator = new @Collator(arguments[1], arguments[2]);\n" \
    "    return collator.compare(thisString, thatString);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeSearchCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeSearchCodeLength = 478;
static const JSC::Intrinsic s_stringPrototypeSearchCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypeSearchCode =
    "(function (regexp)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"String.prototype.search requires that |this| not be null or undefined\");\n" \
    "    if (regexp != null) {\n" \
    "        var searcher = regexp.@searchSymbol;\n" \
    "        if (searcher != @undefined)\n" \
    "            return searcher.@call(regexp, this);\n" \
    "    }\n" \
    "    var thisString = @toString(this);\n" \
    "    var createdRegExp = @regExpCreate(regexp, @undefined);\n" \
    "    return createdRegExp.@searchSymbol(thisString);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_stringPrototypeSplitCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_stringPrototypeSplitCodeLength = 427;
static const JSC::Intrinsic s_stringPrototypeSplitCodeIntrinsic = JSC::NoIntrinsic;
const char* s_stringPrototypeSplitCode =
    "(function (separator, limit)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    \n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"String.prototype.split requires that |this| not be null or undefined\");\n" \
    "    \n" \
    "    if (separator != null) {\n" \
    "        var splitter = separator.@splitSymbol;\n" \
    "        if (splitter != @undefined)\n" \
    "            return splitter.@call(separator, this, limit);\n" \
    "    }\n" \
    "    \n" \
    "    return @stringSplitFast.@call(this, separator, limit);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorOfCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorOfCodeLength = 403;
static const JSC::Intrinsic s_typedArrayConstructorOfCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorOfCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let len = arguments.length;\n" \
    "    let constructFunction = this.@allocateTypedArray;\n" \
    "    if (constructFunction === @undefined)\n" \
    "        throw new @TypeError(\"TypedArray.of requires its this argument to subclass a TypedArray constructor\");\n" \
    "    let result = constructFunction(len);\n" \
    "    for (let i = 0; i < len; i++)\n" \
    "        result[i] = arguments[i];\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorFromCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorFromCodeLength = 2215;
static const JSC::Intrinsic s_typedArrayConstructorFromCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorFromCode =
    "(function (items )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let mapFn = arguments[1];\n" \
    "    let thisArg;\n" \
    "    if (mapFn !== @undefined) {\n" \
    "        if (typeof mapFn !== \"function\")\n" \
    "            throw new @TypeError(\"TypedArray.from requires that the second argument, when provided, be a function\");\n" \
    "        if (arguments.length > 2)\n" \
    "            thisArg = arguments[2];\n" \
    "    }\n" \
    "    if (items == null)\n" \
    "        throw new @TypeError(\"TypedArray.from requires an array-like object - not null or undefined\");\n" \
    "    let iteratorMethod = items.@iteratorSymbol;\n" \
    "    if (iteratorMethod != null) {\n" \
    "        if (typeof iteratorMethod !== \"function\")\n" \
    "            throw new @TypeError(\"TypedArray.from requires that the property of the first argument, items[Symbol.iterator], when exists, be a function\");\n" \
    "        let accumulator = [];\n" \
    "        let k = 0;\n" \
    "        let iterator = iteratorMethod.@call(items);\n" \
    "        let wrapper = {};\n" \
    "        wrapper.@iteratorSymbol = function() { return iterator; }\n" \
    "        for (let value of wrapper) {\n" \
    "            if (mapFn)\n" \
    "                @putByValDirect(accumulator, k, thisArg === @undefined ? mapFn(value, k) : mapFn.@call(thisArg, value, k));\n" \
    "            else\n" \
    "                @putByValDirect(accumulator, k, value);\n" \
    "            k++;\n" \
    "        }\n" \
    "        let constructFunction = this.@allocateTypedArray;\n" \
    "        if (constructFunction === @undefined)\n" \
    "            throw new @TypeError(\"TypedArray.from requires its this argument subclass a TypedArray constructor\");\n" \
    "        let result = constructFunction(k);\n" \
    "        for (let i = 0; i < k; i++) \n" \
    "            result[i] = accumulator[i];\n" \
    "        return result;\n" \
    "    }\n" \
    "    let arrayLike = @Object(items);\n" \
    "    let arrayLikeLength = @toLength(arrayLike.length);\n" \
    "    let constructFunction = this.@allocateTypedArray;\n" \
    "    if (constructFunction === @undefined)\n" \
    "        throw new @TypeError(\"this does not subclass a TypedArray constructor\");\n" \
    "    let result = constructFunction(arrayLikeLength);\n" \
    "    let k = 0;\n" \
    "    while (k < arrayLikeLength) {\n" \
    "        let value = arrayLike[k];\n" \
    "        if (mapFn)\n" \
    "            result[k] = thisArg === @undefined ? mapFn(value, k) : mapFn.@call(thisArg, value, k);\n" \
    "        else\n" \
    "            result[k] = value;\n" \
    "        k++;\n" \
    "    }\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateInt8ArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateInt8ArrayCodeLength = 59;
static const JSC::Intrinsic s_typedArrayConstructorAllocateInt8ArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateInt8ArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Int8Array(length);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateInt16ArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateInt16ArrayCodeLength = 64;
static const JSC::Intrinsic s_typedArrayConstructorAllocateInt16ArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateInt16ArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Int16Array(length);    \n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateInt32ArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateInt32ArrayCodeLength = 63;
static const JSC::Intrinsic s_typedArrayConstructorAllocateInt32ArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateInt32ArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Int32Array(length);   \n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateUint32ArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateUint32ArrayCodeLength = 61;
static const JSC::Intrinsic s_typedArrayConstructorAllocateUint32ArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateUint32ArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Uint32Array(length);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateUint16ArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateUint16ArrayCodeLength = 64;
static const JSC::Intrinsic s_typedArrayConstructorAllocateUint16ArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateUint16ArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Uint16Array(length);   \n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateUint8ArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateUint8ArrayCodeLength = 63;
static const JSC::Intrinsic s_typedArrayConstructorAllocateUint8ArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateUint8ArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Uint8Array(length);   \n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateUint8ClampedArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateUint8ClampedArrayCodeLength = 67;
static const JSC::Intrinsic s_typedArrayConstructorAllocateUint8ClampedArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateUint8ClampedArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Uint8ClampedArray(length);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateFloat32ArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateFloat32ArrayCodeLength = 62;
static const JSC::Intrinsic s_typedArrayConstructorAllocateFloat32ArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateFloat32ArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Float32Array(length);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayConstructorAllocateFloat64ArrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayConstructorAllocateFloat64ArrayCodeLength = 62;
static const JSC::Intrinsic s_typedArrayConstructorAllocateFloat64ArrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayConstructorAllocateFloat64ArrayCode =
    "(function (length)\n" \
    "{\n" \
    "    return new @Float64Array(length);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeTypedArraySpeciesConstructorCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeTypedArraySpeciesConstructorCodeLength = 446;
static const JSC::Intrinsic s_typedArrayPrototypeTypedArraySpeciesConstructorCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeTypedArraySpeciesConstructorCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let constructor = value.constructor;\n" \
    "    if (constructor === @undefined)\n" \
    "        return @typedArrayGetOriginalConstructor(value);\n" \
    "    if (!@isObject(constructor))\n" \
    "        throw new @TypeError(\"|this|.constructor is not an Object or undefined\");\n" \
    "    constructor = constructor.@speciesSymbol;\n" \
    "    if (constructor == null)\n" \
    "        return @typedArrayGetOriginalConstructor(value);\n" \
    "    return constructor;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeTypedArrayClampArgumentToStartOrEndCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeTypedArrayClampArgumentToStartOrEndCodeLength = 281;
static const JSC::Intrinsic s_typedArrayPrototypeTypedArrayClampArgumentToStartOrEndCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeTypedArrayClampArgumentToStartOrEndCode =
    "(function (value, length, undefinedValue)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (value === @undefined)\n" \
    "        return undefinedValue;\n" \
    "    let int = @toInteger(value);\n" \
    "    if (int < 0) {\n" \
    "        int += length;\n" \
    "        return int < 0 ? 0 : int;\n" \
    "    }\n" \
    "    return int > length ? length : int;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeValuesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeValuesCodeLength = 142;
static const JSC::Intrinsic s_typedArrayPrototypeValuesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeValuesCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    @typedArrayLength(this);\n" \
    "    return new @createArrayIterator(this, \"value\", @arrayIteratorValueNext);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeKeysCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeKeysCodeLength = 138;
static const JSC::Intrinsic s_typedArrayPrototypeKeysCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeKeysCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    @typedArrayLength(this);\n" \
    "    return new @createArrayIterator(this, \"key\", @arrayIteratorKeyNext);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeEntriesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeEntriesCodeLength = 149;
static const JSC::Intrinsic s_typedArrayPrototypeEntriesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeEntriesCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    @typedArrayLength(this);\n" \
    "    return new @createArrayIterator(this, \"key+value\", @arrayIteratorKeyValueNext);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeEveryCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeEveryCodeLength = 427;
static const JSC::Intrinsic s_typedArrayPrototypeEveryCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeEveryCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.every callback must be a function\");\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!callback.@call(thisArg, this[i], i, this))\n" \
    "            return false;\n" \
    "    }\n" \
    "    return true;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeFillCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeFillCodeLength = 475;
static const JSC::Intrinsic s_typedArrayPrototypeFillCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeFillCode =
    "(function (value )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let length = @typedArrayLength(this);\n" \
    "    let start;\n" \
    "    let end;\n" \
    "    if (arguments.length > 1) {\n" \
    "        start = arguments[1];\n" \
    "        if (arguments.length > 2) {\n" \
    "            end = arguments[2];\n" \
    "        }\n" \
    "    }\n" \
    "    start = @typedArrayClampArgumentToStartOrEnd(start, length, 0);\n" \
    "    end = @typedArrayClampArgumentToStartOrEnd(end, length, length);\n" \
    "    for (let i = start; i < end; i++)\n" \
    "        this[i] = value;\n" \
    "    return this;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeFindCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeFindCodeLength = 455;
static const JSC::Intrinsic s_typedArrayPrototypeFindCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeFindCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.find callback must be a function\");\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        let elem = this[i];\n" \
    "        if (callback.@call(thisArg, elem, i, this))\n" \
    "            return elem;\n" \
    "    }\n" \
    "    return @undefined;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeFindIndexCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeFindIndexCodeLength = 424;
static const JSC::Intrinsic s_typedArrayPrototypeFindIndexCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeFindIndexCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.findIndex callback must be a function\");\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (callback.@call(thisArg, this[i], i, this))\n" \
    "            return i;\n" \
    "    }\n" \
    "    return -1;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeForEachCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeForEachCodeLength = 373;
static const JSC::Intrinsic s_typedArrayPrototypeForEachCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeForEachCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.forEach callback must be a function\");\n" \
    "    for (var i = 0; i < length; i++)\n" \
    "        callback.@call(thisArg, this[i], i, this);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeSomeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeSomeCodeLength = 425;
static const JSC::Intrinsic s_typedArrayPrototypeSomeCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeSomeCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.some callback must be a function\");\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (callback.@call(thisArg, this[i], i, this))\n" \
    "            return true;\n" \
    "    }\n" \
    "    return false;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeSortCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeSortCodeLength = 1521;
static const JSC::Intrinsic s_typedArrayPrototypeSortCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeSortCode =
    "(function (comparator)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    function min(a, b)\n" \
    "    {\n" \
    "        return a < b ? a : b;\n" \
    "    }\n" \
    "    function merge(dst, src, srcIndex, srcEnd, width, comparator)\n" \
    "    {\n" \
    "        var left = srcIndex;\n" \
    "        var leftEnd = min(left + width, srcEnd);\n" \
    "        var right = leftEnd;\n" \
    "        var rightEnd = min(right + width, srcEnd);\n" \
    "        for (var dstIndex = left; dstIndex < rightEnd; ++dstIndex) {\n" \
    "            if (right < rightEnd) {\n" \
    "                if (left >= leftEnd || comparator(src[right], src[left]) < 0) {\n" \
    "                    dst[dstIndex] = src[right++];\n" \
    "                    continue;\n" \
    "                }\n" \
    "            }\n" \
    "            dst[dstIndex] = src[left++];\n" \
    "        }\n" \
    "    }\n" \
    "    function mergeSort(array, valueCount, comparator)\n" \
    "    {\n" \
    "        var buffer = [ ];\n" \
    "        buffer.length = valueCount;\n" \
    "        var dst = buffer;\n" \
    "        var src = array;\n" \
    "        for (var width = 1; width < valueCount; width *= 2) {\n" \
    "            for (var srcIndex = 0; srcIndex < valueCount; srcIndex += 2 * width)\n" \
    "                merge(dst, src, srcIndex, valueCount, width, comparator);\n" \
    "            var tmp = src;\n" \
    "            src = dst;\n" \
    "            dst = tmp;\n" \
    "        }\n" \
    "        if (src != array) {\n" \
    "            for(var i = 0; i < valueCount; i++)\n" \
    "                array[i] = src[i];\n" \
    "        }\n" \
    "    }\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    if (length < 2)\n" \
    "        return;\n" \
    "    if (typeof comparator == \"function\")\n" \
    "        mergeSort(this, length, comparator);\n" \
    "    else\n" \
    "        @typedArraySort(this);\n" \
    "    \n" \
    "    return this;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeSubarrayCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeSubarrayCodeLength = 399;
static const JSC::Intrinsic s_typedArrayPrototypeSubarrayCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeSubarrayCode =
    "(function (begin, end)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (!@isTypedArrayView(this))\n" \
    "        throw new @TypeError(\"|this| should be a typed array view\");\n" \
    "    let start = @toInteger(begin);\n" \
    "    let finish;\n" \
    "    if (end !== @undefined)\n" \
    "        finish = @toInteger(end);\n" \
    "    let constructor = @typedArraySpeciesConstructor(this);\n" \
    "    return @typedArraySubarrayCreate.@call(this, start, finish, constructor);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeReduceCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeReduceCodeLength = 629;
static const JSC::Intrinsic s_typedArrayPrototypeReduceCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeReduceCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.reduce callback must be a function\");\n" \
    "    if (length === 0 && arguments.length < 2)\n" \
    "        throw new @TypeError(\"TypedArray.prototype.reduce of empty array with no initial value\");\n" \
    "    var accumulator, k = 0;\n" \
    "    if (arguments.length > 1)\n" \
    "        accumulator = arguments[1];\n" \
    "    else\n" \
    "        accumulator = this[k++];\n" \
    "    for (; k < length; k++)\n" \
    "        accumulator = callback.@call(@undefined, accumulator, this[k], k, this);\n" \
    "    return accumulator;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeReduceRightCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeReduceRightCodeLength = 644;
static const JSC::Intrinsic s_typedArrayPrototypeReduceRightCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeReduceRightCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.reduceRight callback must be a function\");\n" \
    "    if (length === 0 && arguments.length < 2)\n" \
    "        throw new @TypeError(\"TypedArray.prototype.reduceRight of empty array with no initial value\");\n" \
    "    var accumulator, k = length - 1;\n" \
    "    if (arguments.length > 1)\n" \
    "        accumulator = arguments[1];\n" \
    "    else\n" \
    "        accumulator = this[k--];\n" \
    "    for (; k >= 0; k--)\n" \
    "        accumulator = callback.@call(@undefined, accumulator, this[k], k, this);\n" \
    "    return accumulator;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeMapCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeMapCodeLength = 969;
static const JSC::Intrinsic s_typedArrayPrototypeMapCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeMapCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.map callback must be a function\");\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    var constructor = this.constructor;\n" \
    "    var result;\n" \
    "    if (constructor === @undefined)\n" \
    "        result = new (@typedArrayGetOriginalConstructor(this))(length);\n" \
    "    else {\n" \
    "        var speciesConstructor = @Object(constructor).@speciesSymbol;\n" \
    "        if (speciesConstructor === null || speciesConstructor === @undefined)\n" \
    "            result = new (@typedArrayGetOriginalConstructor(this))(length);\n" \
    "        else {\n" \
    "            result = new speciesConstructor(length);\n" \
    "            @typedArrayLength(result);\n" \
    "        }\n" \
    "    }\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        var mappedValue = callback.@call(thisArg, this[i], i, this);\n" \
    "        result[i] = mappedValue;\n" \
    "    }\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeFilterCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeFilterCodeLength = 1127;
static const JSC::Intrinsic s_typedArrayPrototypeFilterCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeFilterCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"TypedArray.prototype.filter callback must be a function\");\n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    var kept = [];\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        var value = this[i];\n" \
    "        if (callback.@call(thisArg, value, i, this))\n" \
    "            kept.@push(value);\n" \
    "    }\n" \
    "    var constructor = this.constructor;\n" \
    "    var result;\n" \
    "    var resultLength = kept.length;\n" \
    "    if (constructor === @undefined)\n" \
    "        result = new (@typedArrayGetOriginalConstructor(this))(resultLength);\n" \
    "    else {\n" \
    "        var speciesConstructor = @Object(constructor).@speciesSymbol;\n" \
    "        if (speciesConstructor === null || speciesConstructor === @undefined)\n" \
    "            result = new (@typedArrayGetOriginalConstructor(this))(resultLength);\n" \
    "        else {\n" \
    "            result = new speciesConstructor(resultLength);\n" \
    "            @typedArrayLength(result);\n" \
    "        }\n" \
    "    }\n" \
    "    for (var i = 0; i < kept.length; i++)\n" \
    "        result[i] = kept[i];\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_typedArrayPrototypeToLocaleStringCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_typedArrayPrototypeToLocaleStringCodeLength = 267;
static const JSC::Intrinsic s_typedArrayPrototypeToLocaleStringCodeIntrinsic = JSC::NoIntrinsic;
const char* s_typedArrayPrototypeToLocaleStringCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = @typedArrayLength(this);\n" \
    "    if (length == 0)\n" \
    "        return \"\";\n" \
    "    var string = this[0].toLocaleString();\n" \
    "    for (var i = 1; i < length; i++)\n" \
    "        string += \",\" + this[i].toLocaleString();\n" \
    "    return string;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayConstructorOfCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayConstructorOfCodeLength = 287;
static const JSC::Intrinsic s_arrayConstructorOfCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayConstructorOfCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var length = arguments.length;\n" \
    "    var array = @isConstructor(this) ? new this(length) : @newArrayWithSize(length);\n" \
    "    for (var k = 0; k < length; ++k)\n" \
    "        @putByValDirect(array, k, arguments[k]);\n" \
    "    array.length = length;\n" \
    "    return array;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayConstructorFromCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayConstructorFromCodeLength = 1931;
static const JSC::Intrinsic s_arrayConstructorFromCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayConstructorFromCode =
    "(function (items )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var thisObj = this;\n" \
    "    var mapFn = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    var thisArg;\n" \
    "    if (mapFn !== @undefined) {\n" \
    "        if (typeof mapFn !== \"function\")\n" \
    "            throw new @TypeError(\"Array.from requires that the second argument, when provided, be a function\");\n" \
    "        if (arguments.length > 2)\n" \
    "            thisArg = arguments[2];\n" \
    "    }\n" \
    "    if (items == null)\n" \
    "        throw new @TypeError(\"Array.from requires an array-like object - not null or undefined\");\n" \
    "    var iteratorMethod = items.@iteratorSymbol;\n" \
    "    if (iteratorMethod != null) {\n" \
    "        if (typeof iteratorMethod !== \"function\")\n" \
    "            throw new @TypeError(\"Array.from requires that the property of the first argument, items[Symbol.iterator], when exists, be a function\");\n" \
    "        var result = @isConstructor(thisObj) ? new thisObj() : [];\n" \
    "        var k = 0;\n" \
    "        var iterator = iteratorMethod.@call(items);\n" \
    "        var wrapper = {}\n" \
    "        wrapper.@iteratorSymbol = function() { return iterator; };\n" \
    "        for (var value of wrapper) {\n" \
    "            if (mapFn)\n" \
    "                @putByValDirect(result, k, thisArg === @undefined ? mapFn(value, k) : mapFn.@call(thisArg, value, k));\n" \
    "            else\n" \
    "                @putByValDirect(result, k, value);\n" \
    "            k += 1;\n" \
    "        }\n" \
    "        result.length = k;\n" \
    "        return result;\n" \
    "    }\n" \
    "    var arrayLike = @Object(items);\n" \
    "    var arrayLikeLength = @toLength(arrayLike.length);\n" \
    "    var result = @isConstructor(thisObj) ? new thisObj(arrayLikeLength) : @newArrayWithSize(arrayLikeLength);\n" \
    "    var k = 0;\n" \
    "    while (k < arrayLikeLength) {\n" \
    "        var value = arrayLike[k];\n" \
    "        if (mapFn)\n" \
    "            @putByValDirect(result, k, thisArg === @undefined ? mapFn(value, k) : mapFn.@call(thisArg, value, k));\n" \
    "        else\n" \
    "            @putByValDirect(result, k, value);\n" \
    "        k += 1;\n" \
    "    }\n" \
    "    result.length = arrayLikeLength;\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayIteratorPrototypeArrayIteratorValueNextCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayIteratorPrototypeArrayIteratorValueNextCodeLength = 491;
static const JSC::Intrinsic s_arrayIteratorPrototypeArrayIteratorValueNextCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayIteratorPrototypeArrayIteratorValueNextCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var done = true;\n" \
    "    var value;\n" \
    "    var array = this.@iteratedObject;\n" \
    "    if (!this.@arrayIteratorIsDone) {\n" \
    "        var index = this.@arrayIteratorNextIndex;\n" \
    "        var length = array.length >>> 0;\n" \
    "        if (index >= length) {\n" \
    "            this.@arrayIteratorIsDone = true;\n" \
    "        } else {\n" \
    "            this.@arrayIteratorNextIndex = index + 1;\n" \
    "            done = false;\n" \
    "            value = array[index];\n" \
    "        }\n" \
    "    }\n" \
    "    return { done, value };\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayIteratorPrototypeNextCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayIteratorPrototypeNextCodeLength = 379;
static const JSC::Intrinsic s_arrayIteratorPrototypeNextCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayIteratorPrototypeNextCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"%ArrayIteratorPrototype%.next requires that |this| not be null or undefined\");\n" \
    "    let next = this.@arrayIteratorNext;\n" \
    "    if (next === @undefined)\n" \
    "        throw new @TypeError(\"%ArrayIteratorPrototype%.next requires that |this| be an Array Iterator instance\");\n" \
    "    return next.@call(this);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayIteratorPrototypeArrayIteratorKeyNextCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayIteratorPrototypeArrayIteratorKeyNextCodeLength = 484;
static const JSC::Intrinsic s_arrayIteratorPrototypeArrayIteratorKeyNextCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayIteratorPrototypeArrayIteratorKeyNextCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var done = true;\n" \
    "    var value;\n" \
    "    var array = this.@iteratedObject;\n" \
    "    if (!this.@arrayIteratorIsDone) {\n" \
    "        var index = this.@arrayIteratorNextIndex;\n" \
    "        var length = array.length >>> 0;\n" \
    "        if (index >= length) {\n" \
    "            this.@arrayIteratorIsDone = true;\n" \
    "        } else {\n" \
    "            this.@arrayIteratorNextIndex = index + 1;\n" \
    "            done = false;\n" \
    "            value = index;\n" \
    "        }\n" \
    "    }\n" \
    "    return { done, value };\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayIteratorPrototypeArrayIteratorKeyValueNextCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayIteratorPrototypeArrayIteratorKeyValueNextCodeLength = 502;
static const JSC::Intrinsic s_arrayIteratorPrototypeArrayIteratorKeyValueNextCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayIteratorPrototypeArrayIteratorKeyValueNextCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    var done = true;\n" \
    "    var value;\n" \
    "    var array = this.@iteratedObject;\n" \
    "    if (!this.@arrayIteratorIsDone) {\n" \
    "        var index = this.@arrayIteratorNextIndex;\n" \
    "        var length = array.length >>> 0;\n" \
    "        if (index >= length) {\n" \
    "            this.@arrayIteratorIsDone = true;\n" \
    "        } else {\n" \
    "            this.@arrayIteratorNextIndex = index + 1;\n" \
    "            done = false;\n" \
    "            value = [ index, array[index] ];\n" \
    "        }\n" \
    "    }\n" \
    "    return { done, value };\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeCreateArrayIteratorConstructorCodeConstructAbility = JSC::ConstructAbility::CanConstruct;
const int s_arrayPrototypeCreateArrayIteratorConstructorCodeLength = 262;
static const JSC::Intrinsic s_arrayPrototypeCreateArrayIteratorConstructorCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeCreateArrayIteratorConstructorCode =
    "(function (iteratedObject, kind, iterationFunction)\n" \
    "{\n" \
    "    this.@iteratedObject = iteratedObject;\n" \
    "    this.@arrayIteratorKind = kind;\n" \
    "    this.@arrayIteratorNextIndex = 0;\n" \
    "    this.@arrayIteratorNext = iterationFunction;\n" \
    "    this.@arrayIteratorIsDone = false;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeValuesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeValuesCodeLength = 246;
static const JSC::Intrinsic s_arrayPrototypeValuesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeValuesCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.values requires that |this| not be null or undefined\");\n" \
    "    return new @createArrayIterator(@Object(this), \"value\", @arrayIteratorValueNext);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeKeysCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeKeysCodeLength = 240;
static const JSC::Intrinsic s_arrayPrototypeKeysCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeKeysCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.keys requires that |this| not be null or undefined\");\n" \
    "    return new @createArrayIterator(@Object(this), \"key\", @arrayIteratorKeyNext);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeEntriesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeEntriesCodeLength = 254;
static const JSC::Intrinsic s_arrayPrototypeEntriesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeEntriesCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.entries requires that |this| not be null or undefined\");\n" \
    "    return new @createArrayIterator(@Object(this), \"key+value\", @arrayIteratorKeyValueNext);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeReduceCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeReduceCodeLength = 986;
static const JSC::Intrinsic s_arrayPrototypeReduceCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeReduceCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.reduce requires that |this| not be null or undefined\");\n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.reduce callback must be a function\");\n" \
    "    if (length === 0 && arguments.length < 2)\n" \
    "        throw new @TypeError(\"reduce of empty array with no initial value\");\n" \
    "    var accumulator, k = 0;\n" \
    "    if (arguments.length > 1)\n" \
    "        accumulator = arguments[1];\n" \
    "    else {\n" \
    "        while (k < length && !(k in array))\n" \
    "            k += 1;\n" \
    "        if (k >= length)\n" \
    "            throw new @TypeError(\"reduce of empty array with no initial value\");\n" \
    "        accumulator = array[k++];\n" \
    "    }\n" \
    "    while (k < length) {\n" \
    "        if (k in array)\n" \
    "            accumulator = callback.@call(@undefined, accumulator, array[k], k, array);\n" \
    "        k += 1;\n" \
    "    }\n" \
    "    return accumulator;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeReduceRightCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeReduceRightCodeLength = 1001;
static const JSC::Intrinsic s_arrayPrototypeReduceRightCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeReduceRightCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.reduceRight requires that |this| not be null or undefined\");\n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.reduceRight callback must be a function\");\n" \
    "    if (length === 0 && arguments.length < 2)\n" \
    "        throw new @TypeError(\"reduceRight of empty array with no initial value\");\n" \
    "    var accumulator, k = length - 1;\n" \
    "    if (arguments.length > 1)\n" \
    "        accumulator = arguments[1];\n" \
    "    else {\n" \
    "        while (k >= 0 && !(k in array))\n" \
    "            k -= 1;\n" \
    "        if (k < 0)\n" \
    "            throw new @TypeError(\"reduceRight of empty array with no initial value\");\n" \
    "        accumulator = array[k--];\n" \
    "    }\n" \
    "    while (k >= 0) {\n" \
    "        if (k in array)\n" \
    "            accumulator = callback.@call(@undefined, accumulator, array[k], k, array);\n" \
    "        k -= 1;\n" \
    "    }\n" \
    "    return accumulator;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeEveryCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeEveryCodeLength = 647;
static const JSC::Intrinsic s_arrayPrototypeEveryCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeEveryCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.every requires that |this| not be null or undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.every callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    \n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!(i in array))\n" \
    "            continue;\n" \
    "        if (!callback.@call(thisArg, array[i], i, array))\n" \
    "            return false;\n" \
    "    }\n" \
    "    \n" \
    "    return true;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeForEachCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeForEachCodeLength = 577;
static const JSC::Intrinsic s_arrayPrototypeForEachCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeForEachCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.forEach requires that |this| not be null or undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.forEach callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    \n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (i in array)\n" \
    "            callback.@call(thisArg, array[i], i, array);\n" \
    "    }\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeFilterCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeFilterCodeLength = 1311;
static const JSC::Intrinsic s_arrayPrototypeFilterCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeFilterCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.filter requires that |this| not be null or undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.filter callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    var result;\n" \
    "    var constructor;\n" \
    "    if (@isArray(array)) {\n" \
    "        constructor = array.constructor;\n" \
    "        if (@isArrayConstructor(constructor) && @Array !== constructor)\n" \
    "            constructor = @undefined;\n" \
    "        if (@isObject(constructor)) {\n" \
    "            constructor = constructor.@speciesSymbol;\n" \
    "            if (constructor === null)\n" \
    "                constructor = @undefined;\n" \
    "        }\n" \
    "    }\n" \
    "    if (constructor === @Array || constructor === @undefined)\n" \
    "        result = @newArrayWithSize(0);\n" \
    "    else\n" \
    "        result = new constructor(0);\n" \
    "    var nextIndex = 0;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!(i in array))\n" \
    "            continue;\n" \
    "        var current = array[i]\n" \
    "        if (callback.@call(thisArg, current, i, array)) {\n" \
    "            @putByValDirect(result, nextIndex, current);\n" \
    "            ++nextIndex;\n" \
    "        }\n" \
    "    }\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeMapCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeMapCodeLength = 1254;
static const JSC::Intrinsic s_arrayPrototypeMapCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeMapCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.map requires that |this| not be null or undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.map callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    var result;\n" \
    "    var constructor;\n" \
    "    if (@isArray(array)) {\n" \
    "        constructor = array.constructor;\n" \
    "        if (@isArrayConstructor(constructor) && @Array !== constructor)\n" \
    "            constructor = @undefined;\n" \
    "        if (@isObject(constructor)) {\n" \
    "            constructor = constructor.@speciesSymbol;\n" \
    "            if (constructor === null)\n" \
    "                constructor = @undefined;\n" \
    "        }\n" \
    "    }\n" \
    "    if (constructor === @Array || constructor === @undefined)\n" \
    "        result = @newArrayWithSize(length);\n" \
    "    else\n" \
    "        result = new constructor(length);\n" \
    "    var nextIndex = 0;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!(i in array))\n" \
    "            continue;\n" \
    "        var mappedValue = callback.@call(thisArg, array[i], i, array);\n" \
    "        @putByValDirect(result, i, mappedValue);\n" \
    "    }\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeSomeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeSomeCodeLength = 634;
static const JSC::Intrinsic s_arrayPrototypeSomeCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeSomeCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.some requires that |this| not be null or undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.some callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (!(i in array))\n" \
    "            continue;\n" \
    "        if (callback.@call(thisArg, array[i], i, array))\n" \
    "            return true;\n" \
    "    }\n" \
    "    return false;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeFillCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeFillCodeLength = 1015;
static const JSC::Intrinsic s_arrayPrototypeFillCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeFillCode =
    "(function (value )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.fill requires that |this| not be null or undefined\");\n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    var relativeStart = 0;\n" \
    "    if (arguments.length > 1 && arguments[1] !== @undefined)\n" \
    "        relativeStart = arguments[1] | 0;\n" \
    "    var k = 0;\n" \
    "    if (relativeStart < 0) {\n" \
    "        k = length + relativeStart;\n" \
    "        if (k < 0)\n" \
    "            k = 0;\n" \
    "    } else {\n" \
    "        k = relativeStart;\n" \
    "        if (k > length)\n" \
    "            k = length;\n" \
    "    }\n" \
    "    var relativeEnd = length;\n" \
    "    if (arguments.length > 2 && arguments[2] !== @undefined)\n" \
    "        relativeEnd = arguments[2] | 0;\n" \
    "    var final = 0;\n" \
    "    if (relativeEnd < 0) {\n" \
    "        final = length + relativeEnd;\n" \
    "        if (final < 0)\n" \
    "            final = 0;\n" \
    "    } else {\n" \
    "        final = relativeEnd;\n" \
    "        if (final > length)\n" \
    "            final = length;\n" \
    "    }\n" \
    "    for (; k < final; k++)\n" \
    "        array[k] = value;\n" \
    "    return array;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeFindCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeFindCodeLength = 621;
static const JSC::Intrinsic s_arrayPrototypeFindCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeFindCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.find requires that |this| not be null or undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.find callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        var kValue = array[i];\n" \
    "        if (callback.@call(thisArg, kValue, i, array))\n" \
    "            return kValue;\n" \
    "    }\n" \
    "    return @undefined;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeFindIndexCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeFindIndexCodeLength = 589;
static const JSC::Intrinsic s_arrayPrototypeFindIndexCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeFindIndexCode =
    "(function (callback )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.findIndex requires that |this| not be null or undefined\");\n" \
    "    \n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (typeof callback !== \"function\")\n" \
    "        throw new @TypeError(\"Array.prototype.findIndex callback must be a function\");\n" \
    "    \n" \
    "    var thisArg = arguments.length > 1 ? arguments[1] : @undefined;\n" \
    "    for (var i = 0; i < length; i++) {\n" \
    "        if (callback.@call(thisArg, array[i], i, array))\n" \
    "            return i;\n" \
    "    }\n" \
    "    return -1;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeIncludesCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeIncludesCodeLength = 842;
static const JSC::Intrinsic s_arrayPrototypeIncludesCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeIncludesCode =
    "(function (searchElement )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.includes requires that |this| not be null or undefined\");\n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    if (length === 0)\n" \
    "        return false;\n" \
    "    var fromIndex = 0;\n" \
    "    if (arguments.length > 1 && arguments[1] !== @undefined)\n" \
    "        fromIndex = @toInteger(arguments[1]);\n" \
    "    var index;\n" \
    "    if (fromIndex >= 0)\n" \
    "        index = fromIndex;\n" \
    "    else\n" \
    "        index = length + fromIndex;\n" \
    "    if (index < 0)\n" \
    "        index = 0;\n" \
    "    var currentElement;\n" \
    "    for (; index < length; ++index) {\n" \
    "        currentElement = array[index];\n" \
    "        if (searchElement === currentElement || (searchElement !== searchElement && currentElement !== currentElement))\n" \
    "            return true;\n" \
    "    }\n" \
    "    return false;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeSortCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeSortCodeLength = 5958;
static const JSC::Intrinsic s_arrayPrototypeSortCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeSortCode =
    "(function (comparator)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    function min(a, b)\n" \
    "    {\n" \
    "        return a < b ? a : b;\n" \
    "    }\n" \
    "    function stringComparator(a, b)\n" \
    "    {\n" \
    "        var aString = a.string;\n" \
    "        var bString = b.string;\n" \
    "        var aLength = aString.length;\n" \
    "        var bLength = bString.length;\n" \
    "        var length = min(aLength, bLength);\n" \
    "        for (var i = 0; i < length; ++i) {\n" \
    "            var aCharCode = aString.@charCodeAt(i);\n" \
    "            var bCharCode = bString.@charCodeAt(i);\n" \
    "            if (aCharCode == bCharCode)\n" \
    "                continue;\n" \
    "            return aCharCode - bCharCode;\n" \
    "        }\n" \
    "        return aLength - bLength;\n" \
    "    }\n" \
    "    function compactSparse(array, dst, src, length)\n" \
    "    {\n" \
    "        var values = [ ];\n" \
    "        var seen = { };\n" \
    "        var valueCount = 0;\n" \
    "        var undefinedCount = 0;\n" \
    "        for (var i = dst; i < src; ++i)\n" \
    "            delete array[i];\n" \
    "        for (var object = array; object; object = @Object.@getPrototypeOf(object)) {\n" \
    "            var propertyNames = @Object.@getOwnPropertyNames(object);\n" \
    "            for (var i = 0; i < propertyNames.length; ++i) {\n" \
    "                var index = propertyNames[i];\n" \
    "                if (index < length) {\n" \
    "                    if (seen[index])\n" \
    "                        continue;\n" \
    "                    seen[index] = 1;\n" \
    "                    var value = array[index];\n" \
    "                    delete array[index];\n" \
    "                    if (value === @undefined) {\n" \
    "                        ++undefinedCount;\n" \
    "                        continue;\n" \
    "                    }\n" \
    "                    array[valueCount++] = value;\n" \
    "                }\n" \
    "            }\n" \
    "        }\n" \
    "        for (var i = valueCount; i < valueCount + undefinedCount; ++i)\n" \
    "            array[i] = @undefined;\n" \
    "        return valueCount;\n" \
    "    }\n" \
    "    function compactSlow(array, length)\n" \
    "    {\n" \
    "        var holeCount = 0;\n" \
    "        for (var dst = 0, src = 0; src < length; ++src) {\n" \
    "            if (!(src in array)) {\n" \
    "                ++holeCount;\n" \
    "                if (holeCount < 256)\n" \
    "                    continue;\n" \
    "                return compactSparse(array, dst, src, length);\n" \
    "            }\n" \
    "            var value = array[src];\n" \
    "            if (value === @undefined)\n" \
    "                continue;\n" \
    "            array[dst++] = value;\n" \
    "        }\n" \
    "        var valueCount = dst;\n" \
    "        var undefinedCount = length - valueCount - holeCount;\n" \
    "        for (var i = valueCount; i < valueCount + undefinedCount; ++i)\n" \
    "            array[i] = @undefined;\n" \
    "        for (var i = valueCount + undefinedCount; i < length; ++i)\n" \
    "            delete array[i];\n" \
    "        return valueCount;\n" \
    "    }\n" \
    "    function compact(array, length)\n" \
    "    {\n" \
    "        for (var i = 0; i < array.length; ++i) {\n" \
    "            if (array[i] === @undefined)\n" \
    "                return compactSlow(array, length);\n" \
    "        }\n" \
    "        return length;\n" \
    "    }\n" \
    "    function merge(dst, src, srcIndex, srcEnd, width, comparator)\n" \
    "    {\n" \
    "        var left = srcIndex;\n" \
    "        var leftEnd = min(left + width, srcEnd);\n" \
    "        var right = leftEnd;\n" \
    "        var rightEnd = min(right + width, srcEnd);\n" \
    "        for (var dstIndex = left; dstIndex < rightEnd; ++dstIndex) {\n" \
    "            if (right < rightEnd) {\n" \
    "                if (left >= leftEnd || comparator(src[right], src[left]) < 0) {\n" \
    "                    dst[dstIndex] = src[right++];\n" \
    "                    continue;\n" \
    "                }\n" \
    "            }\n" \
    "            dst[dstIndex] = src[left++];\n" \
    "        }\n" \
    "    }\n" \
    "    function mergeSort(array, valueCount, comparator)\n" \
    "    {\n" \
    "        var buffer = [ ];\n" \
    "        buffer.length = valueCount;\n" \
    "        var dst = buffer;\n" \
    "        var src = array;\n" \
    "        for (var width = 1; width < valueCount; width *= 2) {\n" \
    "            for (var srcIndex = 0; srcIndex < valueCount; srcIndex += 2 * width)\n" \
    "                merge(dst, src, srcIndex, valueCount, width, comparator);\n" \
    "            var tmp = src;\n" \
    "            src = dst;\n" \
    "            dst = tmp;\n" \
    "        }\n" \
    "        if (src != array) {\n" \
    "            for(var i = 0; i < valueCount; i++)\n" \
    "                array[i] = src[i];\n" \
    "        }\n" \
    "    }\n" \
    "    function bucketSort(array, dst, bucket, depth)\n" \
    "    {\n" \
    "        if (bucket.length < 32 || depth > 32) {\n" \
    "            mergeSort(bucket, bucket.length, stringComparator);\n" \
    "            for (var i = 0; i < bucket.length; ++i)\n" \
    "                array[dst++] = bucket[i].value;\n" \
    "            return dst;\n" \
    "        }\n" \
    "        var buckets = [ ];\n" \
    "        for (var i = 0; i < bucket.length; ++i) {\n" \
    "            var entry = bucket[i];\n" \
    "            var string = entry.string;\n" \
    "            if (string.length == depth) {\n" \
    "                array[dst++] = entry.value;\n" \
    "                continue;\n" \
    "            }\n" \
    "            var c = string.@charCodeAt(depth);\n" \
    "            if (!buckets[c])\n" \
    "                buckets[c] = [ ];\n" \
    "            buckets[c][buckets[c].length] = entry;\n" \
    "        }\n" \
    "        for (var i = 0; i < buckets.length; ++i) {\n" \
    "            if (!buckets[i])\n" \
    "                continue;\n" \
    "            dst = bucketSort(array, dst, buckets[i], depth + 1);\n" \
    "        }\n" \
    "        return dst;\n" \
    "    }\n" \
    "    function comparatorSort(array, comparator)\n" \
    "    {\n" \
    "        var length = array.length >>> 0;\n" \
    "        if (length < 2)\n" \
    "            return;\n" \
    "        var valueCount = compact(array, length);\n" \
    "        mergeSort(array, valueCount, comparator);\n" \
    "    }\n" \
    "    function stringSort(array)\n" \
    "    {\n" \
    "        var length = array.length >>> 0;\n" \
    "        if (length < 2)\n" \
    "            return;\n" \
    "        var valueCount = compact(array, length);\n" \
    "        var strings = @newArrayWithSize(valueCount);\n" \
    "        for (var i = 0; i < valueCount; ++i)\n" \
    "            strings[i] = { string: @toString(array[i]), value: array[i] };\n" \
    "        bucketSort(array, 0, strings, 0);\n" \
    "    }\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.sort requires that |this| not be null or undefined\");\n" \
    "    if (typeof this == \"string\")\n" \
    "        throw new @TypeError(\"Attempted to assign to readonly property.\");\n" \
    "    var array = @Object(this);\n" \
    "    if (typeof comparator == \"function\")\n" \
    "        comparatorSort(array, comparator);\n" \
    "    else\n" \
    "        stringSort(array);\n" \
    "    return array;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeConcatSlowPathCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeConcatSlowPathCodeLength = 2083;
static const JSC::Intrinsic s_arrayPrototypeConcatSlowPathCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeConcatSlowPathCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.prototype.concat requires that |this| not be null or undefined\");\n" \
    "    var currentElement = @Object(this);\n" \
    "    var constructor;\n" \
    "    if (@isArray(currentElement)) {\n" \
    "        constructor = currentElement.constructor;\n" \
    "        if (@isArrayConstructor(constructor) && @Array !== constructor)\n" \
    "            constructor = @undefined;\n" \
    "        else if (@isObject(constructor)) {\n" \
    "            constructor = constructor.@speciesSymbol;\n" \
    "            if (constructor === null)\n" \
    "                constructor = @Array;\n" \
    "        }\n" \
    "    }\n" \
    "    var argCount = arguments.length;\n" \
    "    var result;\n" \
    "    if (constructor === @Array || constructor === @undefined)\n" \
    "        result = @newArrayWithSize(0);\n" \
    "    else\n" \
    "        result = new constructor(0);\n" \
    "    var resultIsArray = @isJSArray(result);\n" \
    "    var resultIndex = 0;\n" \
    "    var argIndex = 0;\n" \
    "    do {\n" \
    "        let spreadable = @isObject(currentElement) && currentElement.@isConcatSpreadableSymbol;\n" \
    "        if ((spreadable === @undefined && @isArray(currentElement)) || spreadable) {\n" \
    "            let length = @toLength(currentElement.length);\n" \
    "            if (resultIsArray && @isJSArray(currentElement)) {\n" \
    "                @appendMemcpy(result, currentElement, resultIndex);\n" \
    "                resultIndex += length;\n" \
    "            } else {\n" \
    "                if (length + resultIndex > @MAX_SAFE_INTEGER)\n" \
    "                    throw @TypeError(\"length exceeded the maximum safe integer\");\n" \
    "                for (var i = 0; i < length; i++) {\n" \
    "                    if (i in currentElement)\n" \
    "                        @putByValDirect(result, resultIndex, currentElement[i]);\n" \
    "                    resultIndex++;\n" \
    "                }\n" \
    "            }\n" \
    "        } else {\n" \
    "            if (resultIndex >= @MAX_SAFE_INTEGER)\n" \
    "                throw @TypeError(\"length exceeded the maximum safe integer\");\n" \
    "            @putByValDirect(result, resultIndex++, currentElement);\n" \
    "        }\n" \
    "        currentElement = arguments[argIndex];\n" \
    "    } while (argIndex++ < argCount);\n" \
    "    result.length = resultIndex;\n" \
    "    return result;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeConcatCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeConcatCodeLength = 413;
static const JSC::Intrinsic s_arrayPrototypeConcatCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeConcatCode =
    "(function (first)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (@argumentCount() === 1\n" \
    "        && @isJSArray(this)\n" \
    "        && this.@isConcatSpreadableSymbol === @undefined\n" \
    "        && (!@isObject(first) || first.@isConcatSpreadableSymbol === @undefined)) {\n" \
    "        let result = @concatMemcpy(this, first);\n" \
    "        if (result !== null)\n" \
    "            return result;\n" \
    "    }\n" \
    "    return @tailCallForwardArguments(@concatSlowPath, this);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_arrayPrototypeCopyWithinCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_arrayPrototypeCopyWithinCodeLength = 1703;
static const JSC::Intrinsic s_arrayPrototypeCopyWithinCodeIntrinsic = JSC::NoIntrinsic;
const char* s_arrayPrototypeCopyWithinCode =
    "(function (target, start )\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    function maxWithPositives(a, b)\n" \
    "    {\n" \
    "        return (a < b) ? b : a;\n" \
    "    }\n" \
    "    function minWithMaybeNegativeZeroAndPositive(maybeNegativeZero, positive)\n" \
    "    {\n" \
    "        return (maybeNegativeZero < positive) ? maybeNegativeZero : positive;\n" \
    "    }\n" \
    "    if (this == null)\n" \
    "        throw new @TypeError(\"Array.copyWithin requires that |this| not be null or undefined\");\n" \
    "    var array = @Object(this);\n" \
    "    var length = @toLength(array.length);\n" \
    "    var relativeTarget = @toInteger(target);\n" \
    "    var to = (relativeTarget < 0) ? maxWithPositives(length + relativeTarget, 0) : minWithMaybeNegativeZeroAndPositive(relativeTarget, length);\n" \
    "    var relativeStart = @toInteger(start);\n" \
    "    var from = (relativeStart < 0) ? maxWithPositives(length + relativeStart, 0) : minWithMaybeNegativeZeroAndPositive(relativeStart, length);\n" \
    "    var relativeEnd;\n" \
    "    if (arguments.length >= 3) {\n" \
    "        var end = arguments[2];\n" \
    "        if (end === @undefined)\n" \
    "            relativeEnd = length;\n" \
    "        else\n" \
    "            relativeEnd = @toInteger(end);\n" \
    "    } else\n" \
    "        relativeEnd = length;\n" \
    "    var finalValue = (relativeEnd < 0) ? maxWithPositives(length + relativeEnd, 0) : minWithMaybeNegativeZeroAndPositive(relativeEnd, length);\n" \
    "    var count = minWithMaybeNegativeZeroAndPositive(finalValue - from, length - to);\n" \
    "    var direction = 1;\n" \
    "    if (from < to && to < from + count) {\n" \
    "        direction = -1;\n" \
    "        from = from + count - 1;\n" \
    "        to = to + count - 1;\n" \
    "    }\n" \
    "    for (var i = 0; i < count; ++i, from += direction, to += direction) {\n" \
    "        if (from in array)\n" \
    "            array[to] = array[from];\n" \
    "        else\n" \
    "            delete array[to];\n" \
    "    }\n" \
    "    return array;\n" \
    "})\n" \
;

const JSC::ConstructAbility s_datePrototypeToLocaleStringCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_datePrototypeToLocaleStringCodeLength = 1299;
static const JSC::Intrinsic s_datePrototypeToLocaleStringCodeIntrinsic = JSC::NoIntrinsic;
const char* s_datePrototypeToLocaleStringCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    function toDateTimeOptionsAnyAll(opts)\n" \
    "    {\n" \
    "        var options;\n" \
    "        if (opts === @undefined)\n" \
    "            options = null;\n" \
    "        else if (opts === null)\n" \
    "            throw new @TypeError(\"null is not an object\");\n" \
    "        else\n" \
    "            options = @Object(opts);\n" \
    "        var needsDefaults = !options || (\n" \
    "            options.weekday === @undefined &&\n" \
    "            options.year === @undefined &&\n" \
    "            options.month === @undefined &&\n" \
    "            options.day === @undefined &&\n" \
    "            options.hour === @undefined &&\n" \
    "            options.minute === @undefined &&\n" \
    "            options.second === @undefined\n" \
    "        );\n" \
    "        if (needsDefaults) {\n" \
    "            options = @Object.@create(options);\n" \
    "            options.year = \"numeric\";\n" \
    "            options.month = \"numeric\";\n" \
    "            options.day = \"numeric\";\n" \
    "            options.hour = \"numeric\";\n" \
    "            options.minute = \"numeric\";\n" \
    "            options.second = \"numeric\";\n" \
    "        }\n" \
    "        return options;\n" \
    "    }\n" \
    "    var value = @thisTimeValue.@call(this);\n" \
    "    if (@isNaN(value))\n" \
    "        return \"Invalid Date\";\n" \
    "    var options = toDateTimeOptionsAnyAll(arguments[1]);\n" \
    "    var locales = arguments[0];\n" \
    "    var dateFormat = new @DateTimeFormat(locales, options);\n" \
    "    return dateFormat.format(value);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_datePrototypeToLocaleDateStringCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_datePrototypeToLocaleDateStringCodeLength = 1052;
static const JSC::Intrinsic s_datePrototypeToLocaleDateStringCodeIntrinsic = JSC::NoIntrinsic;
const char* s_datePrototypeToLocaleDateStringCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    function toDateTimeOptionsDateDate(opts)\n" \
    "    {\n" \
    "        var options;\n" \
    "        if (opts === @undefined)\n" \
    "            options = null;\n" \
    "        else if (opts === null)\n" \
    "            throw new @TypeError(\"null is not an object\");\n" \
    "        else\n" \
    "            options = @Object(opts);\n" \
    "        var needsDefaults = !options || (\n" \
    "            options.weekday === @undefined &&\n" \
    "            options.year === @undefined &&\n" \
    "            options.month === @undefined &&\n" \
    "            options.day === @undefined\n" \
    "        );\n" \
    "        if (needsDefaults) {\n" \
    "            options = @Object.@create(options);\n" \
    "            options.year = \"numeric\";\n" \
    "            options.month = \"numeric\";\n" \
    "            options.day = \"numeric\";\n" \
    "        }\n" \
    "        return options;\n" \
    "    }\n" \
    "    var value = @thisTimeValue.@call(this);\n" \
    "    if (@isNaN(value))\n" \
    "        return \"Invalid Date\";\n" \
    "    var options = toDateTimeOptionsDateDate(arguments[1]);\n" \
    "    var locales = arguments[0];\n" \
    "    var dateFormat = new @DateTimeFormat(locales, options);\n" \
    "    return dateFormat.format(value);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_datePrototypeToLocaleTimeStringCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_datePrototypeToLocaleTimeStringCodeLength = 1014;
static const JSC::Intrinsic s_datePrototypeToLocaleTimeStringCodeIntrinsic = JSC::NoIntrinsic;
const char* s_datePrototypeToLocaleTimeStringCode =
    "(function ()\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    function toDateTimeOptionsTimeTime(opts)\n" \
    "    {\n" \
    "        var options;\n" \
    "        if (opts === @undefined)\n" \
    "            options = null;\n" \
    "        else if (opts === null)\n" \
    "            throw new @TypeError(\"null is not an object\");\n" \
    "        else\n" \
    "            options = @Object(opts);\n" \
    "        var needsDefaults = !options || (\n" \
    "            options.hour === @undefined &&\n" \
    "            options.minute === @undefined &&\n" \
    "            options.second === @undefined\n" \
    "        );\n" \
    "        if (needsDefaults) {\n" \
    "            options = @Object.@create(options);\n" \
    "            options.hour = \"numeric\";\n" \
    "            options.minute = \"numeric\";\n" \
    "            options.second = \"numeric\";\n" \
    "        }\n" \
    "        return options;\n" \
    "    }\n" \
    "    var value = @thisTimeValue.@call(this);\n" \
    "    if (@isNaN(value))\n" \
    "        return \"Invalid Date\";\n" \
    "    var options = toDateTimeOptionsTimeTime(arguments[1]);\n" \
    "    var locales = arguments[0];\n" \
    "    var dateFormat = new @DateTimeFormat(locales, options);\n" \
    "    return dateFormat.format(value);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_functionPrototypeCallCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_functionPrototypeCallCodeLength = 238;
static const JSC::Intrinsic s_functionPrototypeCallCodeIntrinsic = JSC::NoIntrinsic;
const char* s_functionPrototypeCallCode =
    "(function (thisArgument)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let argumentValues = [];\n" \
    "    for (let i = 1; i < arguments.length; i++)\n" \
    "        @putByValDirect(argumentValues, i-1, arguments[i]);\n" \
    "    return this.@apply(thisArgument, argumentValues);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_functionPrototypeApplyCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_functionPrototypeApplyCodeLength = 112;
static const JSC::Intrinsic s_functionPrototypeApplyCodeIntrinsic = JSC::NoIntrinsic;
const char* s_functionPrototypeApplyCode =
    "(function (thisValue, argumentValues)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return this.@apply(thisValue, argumentValues);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_functionPrototypeSymbolHasInstanceCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_functionPrototypeSymbolHasInstanceCodeLength = 258;
static const JSC::Intrinsic s_functionPrototypeSymbolHasInstanceCodeIntrinsic = JSC::NoIntrinsic;
const char* s_functionPrototypeSymbolHasInstanceCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    if (typeof this !== \"function\")\n" \
    "        return false;\n" \
    "    if (@isBoundFunction(this))\n" \
    "        return @hasInstanceBoundFunction(this, value);\n" \
    "    let target = this.prototype;\n" \
    "    return @instanceOf(value, target);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_generatorPrototypeGeneratorResumeCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_generatorPrototypeGeneratorResumeCodeLength = 1154;
static const JSC::Intrinsic s_generatorPrototypeGeneratorResumeCodeIntrinsic = JSC::NoIntrinsic;
const char* s_generatorPrototypeGeneratorResumeCode =
    "(function (generator, sentValue, resumeMode)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    let state = generator.@generatorState;\n" \
    "    let done = false;\n" \
    "    let value = @undefined;\n" \
    "    if (typeof state !== 'number')\n" \
    "        throw new @TypeError(\"|this| should be a generator\");\n" \
    "    if (state === @GeneratorStateExecuting)\n" \
    "        throw new @TypeError(\"Generator is executing\");\n" \
    "    if (state === @GeneratorStateCompleted) {\n" \
    "        if (resumeMode === @GeneratorResumeModeThrow)\n" \
    "            throw sentValue;\n" \
    "        done = true;\n" \
    "        if (resumeMode === @GeneratorResumeModeReturn)\n" \
    "            value = sentValue;\n" \
    "    } else {\n" \
    "        try {\n" \
    "            generator.@generatorState = @GeneratorStateExecuting;\n" \
    "            value = generator.@generatorNext.@call(generator.@generatorThis, generator, state, sentValue, resumeMode);\n" \
    "            if (generator.@generatorState === @GeneratorStateExecuting) {\n" \
    "                generator.@generatorState = @GeneratorStateCompleted;\n" \
    "                done = true;\n" \
    "            }\n" \
    "        } catch (error) {\n" \
    "            generator.@generatorState = @GeneratorStateCompleted;\n" \
    "            throw error;\n" \
    "        }\n" \
    "    }\n" \
    "    return { done, value };\n" \
    "})\n" \
;

const JSC::ConstructAbility s_generatorPrototypeNextCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_generatorPrototypeNextCodeLength = 111;
static const JSC::Intrinsic s_generatorPrototypeNextCodeIntrinsic = JSC::NoIntrinsic;
const char* s_generatorPrototypeNextCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return @generatorResume(this, value, @GeneratorResumeModeNormal);\n" \
    "})\n" \
;

const JSC::ConstructAbility s_generatorPrototypeReturnCodeConstructAbility = JSC::ConstructAbility::CannotConstruct;
const int s_generatorPrototypeReturnCodeLength = 111;
static const JSC::Intrinsic s_generatorPrototypeReturnCodeIntrinsic = JSC::NoIntrinsic;
const char* s_generatorPrototypeReturnCode =
    "(function (value)\n" \
    "{\n" \
    "    \"use strict\";\n" \
    "    return @generatorResume(this, value, @GeneratorResumeModeReturn);\n" \
    "})\n" \
;


#define DEFINE_BUILTIN_GENERATOR(codeName, functionName, argumentCount) \
JSC::FunctionExecutable* codeName##Generator(JSC::VM& vm) \
{\
    return vm.builtinExecutables()->codeName##Executable()->link(vm, vm.builtinExecutables()->codeName##Source(), Nullopt, s_##codeName##Intrinsic); }
JSC_FOREACH_BUILTIN_CODE(DEFINE_BUILTIN_GENERATOR)
#undef DEFINE_BUILTIN_GENERATOR


} // namespace JSC
