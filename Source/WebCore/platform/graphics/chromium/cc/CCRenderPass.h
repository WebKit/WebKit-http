/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef CCRenderPass_h
#define CCRenderPass_h

#include "CCDrawQuad.h"
#include "CCOcclusionTracker.h"
#include "CCSharedQuadState.h"
#include "SkColor.h"
#include <public/WebFilterOperations.h>
#include <public/WebTransformationMatrix.h>
#include <wtf/HashMap.h>
#include <wtf/PassOwnPtr.h>
#include <wtf/Vector.h>

namespace WebCore {

class CCLayerImpl;
class CCRenderSurface;

struct CCAppendQuadsData;

// A list of CCDrawQuad objects, sorted internally in front-to-back order.
class CCQuadList : public Vector<OwnPtr<CCDrawQuad> > {
public:
    typedef reverse_iterator backToFrontIterator;
    typedef const_reverse_iterator constBackToFrontIterator;

    inline backToFrontIterator backToFrontBegin() { return rbegin(); }
    inline backToFrontIterator backToFrontEnd() { return rend(); }
    inline constBackToFrontIterator backToFrontBegin() const { return rbegin(); }
    inline constBackToFrontIterator backToFrontEnd() const { return rend(); }
};

typedef Vector<OwnPtr<CCSharedQuadState> > CCSharedQuadStateList;

class CCRenderPass {
    WTF_MAKE_NONCOPYABLE(CCRenderPass);
public:
    struct Id {
        int layerId;
        int index;

        Id(int layerId, int index)
            : layerId(layerId)
            , index(index)
        {
        }

        bool operator==(const Id& other) const { return layerId == other.layerId && index == other.index; }
        bool operator!=(const Id& other) const { return !(*this == other); }
        bool operator<(const Id& other) const { return layerId < other.layerId || (layerId == other.layerId && index < other.index); }
    };

    static PassOwnPtr<CCRenderPass> create(Id, IntRect outputRect, const WebKit::WebTransformationMatrix& transformToRootTarget);

    // A shallow copy of the render pass, which does not include its quads.
    PassOwnPtr<CCRenderPass> copy(Id newId) const;

    void appendQuadsForLayer(CCLayerImpl*, CCOcclusionTrackerImpl*, CCAppendQuadsData&);
    void appendQuadsForRenderSurfaceLayer(CCLayerImpl*, const CCRenderPass* contributingRenderPass, CCOcclusionTrackerImpl*, CCAppendQuadsData&);
    void appendQuadsToFillScreen(CCLayerImpl* rootLayer, SkColor screenBackgroundColor, const CCOcclusionTrackerImpl&);

    const CCQuadList& quadList() const { return m_quadList; }

    Id id() const { return m_id; }

    // FIXME: Modify this transform when merging the RenderPass into a parent compositor.
    // Transforms from quad's original content space to the root target's content space.
    const WebKit::WebTransformationMatrix& transformToRootTarget() const { return m_transformToRootTarget; }

    // This denotes the bounds in physical pixels of the output generated by this RenderPass.
    const IntRect& outputRect() const { return m_outputRect; }

    FloatRect damageRect() const { return m_damageRect; }
    void setDamageRect(FloatRect rect) { m_damageRect = rect; }

    const WebKit::WebFilterOperations& filters() const { return m_filters; }
    void setFilters(const WebKit::WebFilterOperations& filters) { m_filters = filters; }

    const WebKit::WebFilterOperations& backgroundFilters() const { return m_backgroundFilters; }
    void setBackgroundFilters(const WebKit::WebFilterOperations& filters) { m_backgroundFilters = filters; }

    bool hasTransparentBackground() const { return m_hasTransparentBackground; }
    void setHasTransparentBackground(bool transparent) { m_hasTransparentBackground = transparent; }

    bool hasOcclusionFromOutsideTargetSurface() const { return m_hasOcclusionFromOutsideTargetSurface; }
    void setHasOcclusionFromOutsideTargetSurface(bool hasOcclusionFromOutsideTargetSurface) { m_hasOcclusionFromOutsideTargetSurface = hasOcclusionFromOutsideTargetSurface; }
protected:
    CCRenderPass(Id, IntRect outputRect, const WebKit::WebTransformationMatrix& transformToRootTarget);

    Id m_id;
    CCQuadList m_quadList;
    CCSharedQuadStateList m_sharedQuadStateList;
    WebKit::WebTransformationMatrix m_transformToRootTarget;
    IntRect m_outputRect;
    FloatRect m_damageRect;
    bool m_hasTransparentBackground;
    bool m_hasOcclusionFromOutsideTargetSurface;
    WebKit::WebFilterOperations m_filters;
    WebKit::WebFilterOperations m_backgroundFilters;
};

} // namespace WebCore

namespace WTF {
template<> struct HashTraits<WebCore::CCRenderPass::Id> : GenericHashTraits<WebCore::CCRenderPass::Id> {
    static const bool emptyValueIsZero = false;
    static const bool needsDestruction = false;
    static WebCore::CCRenderPass::Id emptyValue() { return WebCore::CCRenderPass::Id(0, 0); }
    static void constructDeletedValue(WebCore::CCRenderPass::Id& slot) { slot = WebCore::CCRenderPass::Id(-1, -1); }
    static bool isDeletedValue(WebCore::CCRenderPass::Id value) { return value.layerId == -1 && value.index == -1; }
};
template<> struct IntHash<WebCore::CCRenderPass::Id> {
    static unsigned hash(const WebCore::CCRenderPass::Id& key) { return PairHash<int, int>::hash(std::make_pair(key.layerId, key.index)); }
    static bool equal(const WebCore::CCRenderPass::Id& a, const WebCore::CCRenderPass::Id& b) { return a == b; }
    static const bool safeToCompareToEmptyOrDeleted = true;
};
template<> struct DefaultHash<WebCore::CCRenderPass::Id> {
    typedef IntHash<WebCore::CCRenderPass::Id> Hash;
};
} // namespace WTF

namespace WebCore {
typedef Vector<CCRenderPass*> CCRenderPassList;
typedef HashMap<CCRenderPass::Id, OwnPtr<CCRenderPass> > CCRenderPassIdHashMap;
} // namespace WebCore

#endif
