/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from CombinedDomains.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "InspectorProtocolObjects.h"

#include <wtf/Optional.h>
#include <wtf/text/CString.h>

namespace Inspector {

namespace Protocol {

namespace InspectorHelpers {

static const char* const enum_constant_values[] = {
    "user",
    "user-agent",
    "inspector",
    "regular",
    "active",
    "inactive",
    "disabled",
    "style",
    "mediaRule",
    "importRule",
    "linkedSheet",
    "inlineSheet",
    "overset",
    "fit",
    "empty",
    "xml",
    "javascript",
    "network",
    "console-api",
    "storage",
    "appcache",
    "rendering",
    "css",
    "security",
    "content-blocker",
    "other",
    "log",
    "info",
    "warning",
    "error",
    "debug",
    "dir",
    "dirxml",
    "table",
    "trace",
    "clear",
    "startGroup",
    "startGroupCollapsed",
    "endGroup",
    "assert",
    "timing",
    "profile",
    "profileEnd",
    "before",
    "after",
    "additions",
    "removals",
    "text",
    "true",
    "false",
    "mixed",
    "page",
    "step",
    "location",
    "date",
    "time",
    "grammar",
    "spelling",
    "assertive",
    "polite",
    "off",
    "subtree-modified",
    "attribute-modified",
    "node-removed",
    "evaluate",
    "sound",
    "probe",
    "global",
    "with",
    "closure",
    "catch",
    "functionName",
    "globalLexicalEnvironment",
    "nestedLexical",
    "full",
    "partial",
    "number",
    "string",
    "array",
    "null",
    "Document",
    "Stylesheet",
    "Image",
    "Font",
    "Script",
    "XHR",
    "WebSocket",
    "Other",
    "parser",
    "script",
    "Viewport",
    "Page",
    "object",
    "function",
    "undefined",
    "boolean",
    "symbol",
    "node",
    "regexp",
    "map",
    "set",
    "weakmap",
    "weakset",
    "iterator",
    "class",
    "accessor",
    "none",
    "irrecoverable",
    "unterminated-literal",
    "recoverable",
    "API",
    "Microtask",
    "EventDispatch",
    "ScheduleStyleRecalculation",
    "RecalculateStyles",
    "InvalidateLayout",
    "Layout",
    "Paint",
    "Composite",
    "RenderingFrame",
    "TimerInstall",
    "TimerRemove",
    "TimerFire",
    "EvaluateScript",
    "TimeStamp",
    "Time",
    "TimeEnd",
    "FunctionCall",
    "ProbeSample",
    "ConsoleProfile",
    "RequestAnimationFrame",
    "CancelAnimationFrame",
    "FireAnimationFrame",
    "ScriptProfiler",
    "Timeline",
    "Memory",
    "Heap",
    "DOM",
    "EventListener",
    "exception",
    "CSPViolation",
    "DebuggerStatement",
    "Breakpoint",
    "PauseOnNextStatement",
    "uncaught",
    "all",
    "allowed",
    "forbidden",
};

String getEnumConstantValue(int code) {
    return enum_constant_values[code];
}

// Enums in the 'CSS' Domain
template<>
Optional<Inspector::Protocol::CSS::StyleSheetOrigin> parseEnumValueFromString<Inspector::Protocol::CSS::StyleSheetOrigin>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::CSS::StyleSheetOrigin::User,
        (size_t)Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent,
        (size_t)Inspector::Protocol::CSS::StyleSheetOrigin::Inspector,
        (size_t)Inspector::Protocol::CSS::StyleSheetOrigin::Regular,
    };
    for (size_t i = 0; i < 4; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::CSS::StyleSheetOrigin)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::CSS::CSSPropertyStatus> parseEnumValueFromString<Inspector::Protocol::CSS::CSSPropertyStatus>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::CSS::CSSPropertyStatus::Active,
        (size_t)Inspector::Protocol::CSS::CSSPropertyStatus::Inactive,
        (size_t)Inspector::Protocol::CSS::CSSPropertyStatus::Disabled,
        (size_t)Inspector::Protocol::CSS::CSSPropertyStatus::Style,
    };
    for (size_t i = 0; i < 4; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::CSS::CSSPropertyStatus)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::CSS::CSSMedia::Source> parseEnumValueFromString<Inspector::Protocol::CSS::CSSMedia::Source>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::CSS::CSSMedia::Source::MediaRule,
        (size_t)Inspector::Protocol::CSS::CSSMedia::Source::ImportRule,
        (size_t)Inspector::Protocol::CSS::CSSMedia::Source::LinkedSheet,
        (size_t)Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet,
    };
    for (size_t i = 0; i < 4; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::CSS::CSSMedia::Source)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::CSS::Region::RegionOverset> parseEnumValueFromString<Inspector::Protocol::CSS::Region::RegionOverset>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::CSS::Region::RegionOverset::Overset,
        (size_t)Inspector::Protocol::CSS::Region::RegionOverset::Fit,
        (size_t)Inspector::Protocol::CSS::Region::RegionOverset::Empty,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::CSS::Region::RegionOverset)constantValues[i];

    return Nullopt;
}


// Enums in the 'Console' Domain
template<>
Optional<Inspector::Protocol::Console::ConsoleMessage::Source> parseEnumValueFromString<Inspector::Protocol::Console::ConsoleMessage::Source>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::XML,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::Javascript,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::Network,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::ConsoleAPI,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::Storage,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::Appcache,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::Rendering,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::CSS,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::Security,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::ContentBlocker,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Source::Other,
    };
    for (size_t i = 0; i < 11; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Console::ConsoleMessage::Source)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Console::ConsoleMessage::Level> parseEnumValueFromString<Inspector::Protocol::Console::ConsoleMessage::Level>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Level::Log,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Level::Info,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Level::Warning,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Level::Error,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Level::Debug,
    };
    for (size_t i = 0; i < 5; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Console::ConsoleMessage::Level)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Console::ConsoleMessage::Type> parseEnumValueFromString<Inspector::Protocol::Console::ConsoleMessage::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::Log,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::Dir,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::DirXML,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::Table,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::Trace,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::Clear,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::StartGroup,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::StartGroupCollapsed,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::EndGroup,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::Assert,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::Timing,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::Profile,
        (size_t)Inspector::Protocol::Console::ConsoleMessage::Type::ProfileEnd,
    };
    for (size_t i = 0; i < 13; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Console::ConsoleMessage::Type)constantValues[i];

    return Nullopt;
}


// Enums in the 'DOM' Domain
template<>
Optional<Inspector::Protocol::DOM::PseudoType> parseEnumValueFromString<Inspector::Protocol::DOM::PseudoType>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::DOM::PseudoType::Before,
        (size_t)Inspector::Protocol::DOM::PseudoType::After,
    };
    for (size_t i = 0; i < 2; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::DOM::PseudoType)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::DOM::LiveRegionRelevant> parseEnumValueFromString<Inspector::Protocol::DOM::LiveRegionRelevant>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::DOM::LiveRegionRelevant::Additions,
        (size_t)Inspector::Protocol::DOM::LiveRegionRelevant::Removals,
        (size_t)Inspector::Protocol::DOM::LiveRegionRelevant::Text,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::DOM::LiveRegionRelevant)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::DOM::AccessibilityProperties::Checked> parseEnumValueFromString<Inspector::Protocol::DOM::AccessibilityProperties::Checked>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Checked::True,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Checked::False,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Checked::Mixed,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::DOM::AccessibilityProperties::Checked)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::DOM::AccessibilityProperties::Current> parseEnumValueFromString<Inspector::Protocol::DOM::AccessibilityProperties::Current>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Current::True,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Current::False,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Current::Page,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Current::Step,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Current::Location,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Current::Date,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Current::Time,
    };
    for (size_t i = 0; i < 7; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::DOM::AccessibilityProperties::Current)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::DOM::AccessibilityProperties::Invalid> parseEnumValueFromString<Inspector::Protocol::DOM::AccessibilityProperties::Invalid>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Invalid::True,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Invalid::Grammar,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::Invalid::Spelling,
    };
    for (size_t i = 0; i < 4; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::DOM::AccessibilityProperties::Invalid)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus> parseEnumValueFromString<Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Assertive,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Polite,
        (size_t)Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Off,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus)constantValues[i];

    return Nullopt;
}


// Enums in the 'DOMDebugger' Domain
template<>
Optional<Inspector::Protocol::DOMDebugger::DOMBreakpointType> parseEnumValueFromString<Inspector::Protocol::DOMDebugger::DOMBreakpointType>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::DOMDebugger::DOMBreakpointType::SubtreeModified,
        (size_t)Inspector::Protocol::DOMDebugger::DOMBreakpointType::AttributeModified,
        (size_t)Inspector::Protocol::DOMDebugger::DOMBreakpointType::NodeRemoved,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::DOMDebugger::DOMBreakpointType)constantValues[i];

    return Nullopt;
}


// Enums in the 'Debugger' Domain
template<>
Optional<Inspector::Protocol::Debugger::BreakpointAction::Type> parseEnumValueFromString<Inspector::Protocol::Debugger::BreakpointAction::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Debugger::BreakpointAction::Type::Log,
        (size_t)Inspector::Protocol::Debugger::BreakpointAction::Type::Evaluate,
        (size_t)Inspector::Protocol::Debugger::BreakpointAction::Type::Sound,
        (size_t)Inspector::Protocol::Debugger::BreakpointAction::Type::Probe,
    };
    for (size_t i = 0; i < 4; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Debugger::BreakpointAction::Type)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Debugger::Scope::Type> parseEnumValueFromString<Inspector::Protocol::Debugger::Scope::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Debugger::Scope::Type::Global,
        (size_t)Inspector::Protocol::Debugger::Scope::Type::With,
        (size_t)Inspector::Protocol::Debugger::Scope::Type::Closure,
        (size_t)Inspector::Protocol::Debugger::Scope::Type::Catch,
        (size_t)Inspector::Protocol::Debugger::Scope::Type::FunctionName,
        (size_t)Inspector::Protocol::Debugger::Scope::Type::GlobalLexicalEnvironment,
        (size_t)Inspector::Protocol::Debugger::Scope::Type::NestedLexical,
    };
    for (size_t i = 0; i < 7; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Debugger::Scope::Type)constantValues[i];

    return Nullopt;
}


// Enums in the 'Heap' Domain
template<>
Optional<Inspector::Protocol::Heap::GarbageCollection::Type> parseEnumValueFromString<Inspector::Protocol::Heap::GarbageCollection::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Heap::GarbageCollection::Type::Full,
        (size_t)Inspector::Protocol::Heap::GarbageCollection::Type::Partial,
    };
    for (size_t i = 0; i < 2; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Heap::GarbageCollection::Type)constantValues[i];

    return Nullopt;
}


#if ENABLE(INDEXED_DATABASE)
// Enums in the 'IndexedDB' Domain
template<>
Optional<Inspector::Protocol::IndexedDB::Key::Type> parseEnumValueFromString<Inspector::Protocol::IndexedDB::Key::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::IndexedDB::Key::Type::Number,
        (size_t)Inspector::Protocol::IndexedDB::Key::Type::String,
        (size_t)Inspector::Protocol::IndexedDB::Key::Type::Date,
        (size_t)Inspector::Protocol::IndexedDB::Key::Type::Array,
    };
    for (size_t i = 0; i < 4; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::IndexedDB::Key::Type)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::IndexedDB::KeyPath::Type> parseEnumValueFromString<Inspector::Protocol::IndexedDB::KeyPath::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::IndexedDB::KeyPath::Type::Null,
        (size_t)Inspector::Protocol::IndexedDB::KeyPath::Type::String,
        (size_t)Inspector::Protocol::IndexedDB::KeyPath::Type::Array,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::IndexedDB::KeyPath::Type)constantValues[i];

    return Nullopt;
}

#endif // ENABLE(INDEXED_DATABASE)

// Enums in the 'Network' Domain
template<>
Optional<Inspector::Protocol::Network::Initiator::Type> parseEnumValueFromString<Inspector::Protocol::Network::Initiator::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Network::Initiator::Type::Parser,
        (size_t)Inspector::Protocol::Network::Initiator::Type::Script,
        (size_t)Inspector::Protocol::Network::Initiator::Type::Other,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Network::Initiator::Type)constantValues[i];

    return Nullopt;
}


// Enums in the 'Page' Domain
template<>
Optional<Inspector::Protocol::Page::ResourceType> parseEnumValueFromString<Inspector::Protocol::Page::ResourceType>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Page::ResourceType::Document,
        (size_t)Inspector::Protocol::Page::ResourceType::Stylesheet,
        (size_t)Inspector::Protocol::Page::ResourceType::Image,
        (size_t)Inspector::Protocol::Page::ResourceType::Font,
        (size_t)Inspector::Protocol::Page::ResourceType::Script,
        (size_t)Inspector::Protocol::Page::ResourceType::XHR,
        (size_t)Inspector::Protocol::Page::ResourceType::WebSocket,
        (size_t)Inspector::Protocol::Page::ResourceType::Other,
    };
    for (size_t i = 0; i < 8; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Page::ResourceType)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Page::CoordinateSystem> parseEnumValueFromString<Inspector::Protocol::Page::CoordinateSystem>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Page::CoordinateSystem::Viewport,
        (size_t)Inspector::Protocol::Page::CoordinateSystem::Page,
    };
    for (size_t i = 0; i < 2; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Page::CoordinateSystem)constantValues[i];

    return Nullopt;
}


// Enums in the 'Runtime' Domain
template<>
Optional<Inspector::Protocol::Runtime::SyntaxErrorType> parseEnumValueFromString<Inspector::Protocol::Runtime::SyntaxErrorType>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Runtime::SyntaxErrorType::None,
        (size_t)Inspector::Protocol::Runtime::SyntaxErrorType::Irrecoverable,
        (size_t)Inspector::Protocol::Runtime::SyntaxErrorType::UnterminatedLiteral,
        (size_t)Inspector::Protocol::Runtime::SyntaxErrorType::Recoverable,
    };
    for (size_t i = 0; i < 4; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Runtime::SyntaxErrorType)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Runtime::RemoteObject::Type> parseEnumValueFromString<Inspector::Protocol::Runtime::RemoteObject::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Type::Object,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Type::Function,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Type::Undefined,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Type::String,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Type::Number,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Type::Boolean,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Type::Symbol,
    };
    for (size_t i = 0; i < 7; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Runtime::RemoteObject::Type)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Runtime::RemoteObject::Subtype> parseEnumValueFromString<Inspector::Protocol::Runtime::RemoteObject::Subtype>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Array,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Null,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Node,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Regexp,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Date,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Error,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Map,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Set,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Weakmap,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Weakset,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Iterator,
        (size_t)Inspector::Protocol::Runtime::RemoteObject::Subtype::Class,
    };
    for (size_t i = 0; i < 12; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Runtime::RemoteObject::Subtype)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Runtime::ObjectPreview::Type> parseEnumValueFromString<Inspector::Protocol::Runtime::ObjectPreview::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Type::Object,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Type::Function,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Type::Undefined,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Type::String,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Type::Number,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Type::Boolean,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Type::Symbol,
    };
    for (size_t i = 0; i < 7; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Runtime::ObjectPreview::Type)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Runtime::ObjectPreview::Subtype> parseEnumValueFromString<Inspector::Protocol::Runtime::ObjectPreview::Subtype>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Array,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Null,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Node,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Regexp,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Date,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Error,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Map,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Set,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Weakmap,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Weakset,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Iterator,
        (size_t)Inspector::Protocol::Runtime::ObjectPreview::Subtype::Class,
    };
    for (size_t i = 0; i < 12; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Runtime::ObjectPreview::Subtype)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Runtime::PropertyPreview::Type> parseEnumValueFromString<Inspector::Protocol::Runtime::PropertyPreview::Type>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Type::Object,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Type::Function,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Type::Undefined,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Type::String,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Type::Number,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Type::Boolean,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Type::Symbol,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Type::Accessor,
    };
    for (size_t i = 0; i < 8; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Runtime::PropertyPreview::Type)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Runtime::PropertyPreview::Subtype> parseEnumValueFromString<Inspector::Protocol::Runtime::PropertyPreview::Subtype>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Array,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Null,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Node,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Regexp,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Date,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Error,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Map,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Set,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Weakmap,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Weakset,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Iterator,
        (size_t)Inspector::Protocol::Runtime::PropertyPreview::Subtype::Class,
    };
    for (size_t i = 0; i < 12; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Runtime::PropertyPreview::Subtype)constantValues[i];

    return Nullopt;
}


// Enums in the 'ScriptProfiler' Domain
template<>
Optional<Inspector::Protocol::ScriptProfiler::EventType> parseEnumValueFromString<Inspector::Protocol::ScriptProfiler::EventType>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::ScriptProfiler::EventType::API,
        (size_t)Inspector::Protocol::ScriptProfiler::EventType::Microtask,
        (size_t)Inspector::Protocol::ScriptProfiler::EventType::Other,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::ScriptProfiler::EventType)constantValues[i];

    return Nullopt;
}


// Enums in the 'Timeline' Domain
template<>
Optional<Inspector::Protocol::Timeline::EventType> parseEnumValueFromString<Inspector::Protocol::Timeline::EventType>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Timeline::EventType::EventDispatch,
        (size_t)Inspector::Protocol::Timeline::EventType::ScheduleStyleRecalculation,
        (size_t)Inspector::Protocol::Timeline::EventType::RecalculateStyles,
        (size_t)Inspector::Protocol::Timeline::EventType::InvalidateLayout,
        (size_t)Inspector::Protocol::Timeline::EventType::Layout,
        (size_t)Inspector::Protocol::Timeline::EventType::Paint,
        (size_t)Inspector::Protocol::Timeline::EventType::Composite,
        (size_t)Inspector::Protocol::Timeline::EventType::RenderingFrame,
        (size_t)Inspector::Protocol::Timeline::EventType::TimerInstall,
        (size_t)Inspector::Protocol::Timeline::EventType::TimerRemove,
        (size_t)Inspector::Protocol::Timeline::EventType::TimerFire,
        (size_t)Inspector::Protocol::Timeline::EventType::EvaluateScript,
        (size_t)Inspector::Protocol::Timeline::EventType::TimeStamp,
        (size_t)Inspector::Protocol::Timeline::EventType::Time,
        (size_t)Inspector::Protocol::Timeline::EventType::TimeEnd,
        (size_t)Inspector::Protocol::Timeline::EventType::FunctionCall,
        (size_t)Inspector::Protocol::Timeline::EventType::ProbeSample,
        (size_t)Inspector::Protocol::Timeline::EventType::ConsoleProfile,
        (size_t)Inspector::Protocol::Timeline::EventType::RequestAnimationFrame,
        (size_t)Inspector::Protocol::Timeline::EventType::CancelAnimationFrame,
        (size_t)Inspector::Protocol::Timeline::EventType::FireAnimationFrame,
    };
    for (size_t i = 0; i < 21; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Timeline::EventType)constantValues[i];

    return Nullopt;
}

template<>
Optional<Inspector::Protocol::Timeline::Instrument> parseEnumValueFromString<Inspector::Protocol::Timeline::Instrument>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Timeline::Instrument::ScriptProfiler,
        (size_t)Inspector::Protocol::Timeline::Instrument::Timeline,
        (size_t)Inspector::Protocol::Timeline::Instrument::Memory,
        (size_t)Inspector::Protocol::Timeline::Instrument::Heap,
    };
    for (size_t i = 0; i < 4; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Timeline::Instrument)constantValues[i];

    return Nullopt;
}


} // namespace InspectorHelpers

const char* Inspector::Protocol::CSS::CSSProperty::Implicit = "implicit";
const char* Inspector::Protocol::CSS::CSSProperty::Name = "name";
const char* Inspector::Protocol::CSS::CSSProperty::ParsedOk = "parsedOk";
const char* Inspector::Protocol::CSS::CSSProperty::Priority = "priority";
const char* Inspector::Protocol::CSS::CSSProperty::Range = "range";
const char* Inspector::Protocol::CSS::CSSProperty::Status = "status";
const char* Inspector::Protocol::CSS::CSSProperty::Text = "text";
const char* Inspector::Protocol::CSS::CSSProperty::Value = "value";
const char* Inspector::Protocol::Network::Response::FromDiskCache = "fromDiskCache";
const char* Inspector::Protocol::Network::Response::Headers = "headers";
const char* Inspector::Protocol::Network::Response::HeadersText = "headersText";
const char* Inspector::Protocol::Network::Response::MimeType = "mimeType";
const char* Inspector::Protocol::Network::Response::RequestHeaders = "requestHeaders";
const char* Inspector::Protocol::Network::Response::RequestHeadersText = "requestHeadersText";
const char* Inspector::Protocol::Network::Response::Status = "status";
const char* Inspector::Protocol::Network::Response::StatusText = "statusText";
const char* Inspector::Protocol::Network::Response::Timing = "timing";
const char* Inspector::Protocol::Network::Response::Url = "url";
const char* Inspector::Protocol::Timeline::TimelineEvent::Children = "children";
const char* Inspector::Protocol::Timeline::TimelineEvent::Data = "data";
const char* Inspector::Protocol::Timeline::TimelineEvent::Type = "type";

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Debugger::Location>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator scriptIdPos = object->find(ASCIILiteral("scriptId"));
        ASSERT(scriptIdPos != object->end());
        BindingTraits<String>::assertValueHasExpectedType(scriptIdPos->value.get());
    }
    {
        InspectorObject::iterator lineNumberPos = object->find(ASCIILiteral("lineNumber"));
        ASSERT(lineNumberPos != object->end());
        BindingTraits<int>::assertValueHasExpectedType(lineNumberPos->value.get());
    }

    int foundPropertiesCount = 2;
    {
        InspectorObject::iterator columnNumberPos = object->find(ASCIILiteral("columnNumber"));
        if (columnNumberPos != object->end()) {
            BindingTraits<int>::assertValueHasExpectedType(columnNumberPos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Debugger::FunctionDetails>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator locationPos = object->find(ASCIILiteral("location"));
        ASSERT(locationPos != object->end());
        BindingTraits<Inspector::Protocol::Debugger::Location>::assertValueHasExpectedType(locationPos->value.get());
    }

    int foundPropertiesCount = 1;
    {
        InspectorObject::iterator namePos = object->find(ASCIILiteral("name"));
        if (namePos != object->end()) {
            BindingTraits<String>::assertValueHasExpectedType(namePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator displayNamePos = object->find(ASCIILiteral("displayName"));
        if (displayNamePos != object->end()) {
            BindingTraits<String>::assertValueHasExpectedType(displayNamePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator scopeChainPos = object->find(ASCIILiteral("scopeChain"));
        if (scopeChainPos != object->end()) {
            BindingTraits<Inspector::Protocol::Array<Inspector::Protocol::Debugger::Scope>>::assertValueHasExpectedType(scopeChainPos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

RefPtr<Inspector::Protocol::Debugger::FunctionDetails> BindingTraits<Inspector::Protocol::Debugger::FunctionDetails>::runtimeCast(RefPtr<InspectorValue>&& value)
{
    RefPtr<InspectorObject> result;
    bool castSucceeded = value->asObject(result);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
#if !ASSERT_DISABLED
    BindingTraits<Inspector::Protocol::Debugger::FunctionDetails>::assertValueHasExpectedType(result.get());
#endif  // !ASSERT_DISABLED
    COMPILE_ASSERT(sizeof(Inspector::Protocol::Debugger::FunctionDetails) == sizeof(InspectorObjectBase), type_cast_problem);
    return static_cast<Inspector::Protocol::Debugger::FunctionDetails*>(static_cast<InspectorObjectBase*>(result.get()));
}


#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Debugger::CallFrame>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator callFrameIdPos = object->find(ASCIILiteral("callFrameId"));
        ASSERT(callFrameIdPos != object->end());
        BindingTraits<String>::assertValueHasExpectedType(callFrameIdPos->value.get());
    }
    {
        InspectorObject::iterator functionNamePos = object->find(ASCIILiteral("functionName"));
        ASSERT(functionNamePos != object->end());
        BindingTraits<String>::assertValueHasExpectedType(functionNamePos->value.get());
    }
    {
        InspectorObject::iterator locationPos = object->find(ASCIILiteral("location"));
        ASSERT(locationPos != object->end());
        BindingTraits<Inspector::Protocol::Debugger::Location>::assertValueHasExpectedType(locationPos->value.get());
    }
    {
        InspectorObject::iterator scopeChainPos = object->find(ASCIILiteral("scopeChain"));
        ASSERT(scopeChainPos != object->end());
        BindingTraits<Inspector::Protocol::Array<Inspector::Protocol::Debugger::Scope>>::assertValueHasExpectedType(scopeChainPos->value.get());
    }
    {
        InspectorObject::iterator thisPos = object->find(ASCIILiteral("this"));
        ASSERT(thisPos != object->end());
        BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(thisPos->value.get());
    }
    {
        InspectorObject::iterator isTailDeletedPos = object->find(ASCIILiteral("isTailDeleted"));
        ASSERT(isTailDeletedPos != object->end());
        BindingTraits<bool>::assertValueHasExpectedType(isTailDeletedPos->value.get());
    }

    int foundPropertiesCount = 6;
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

RefPtr<Inspector::Protocol::Debugger::CallFrame> BindingTraits<Inspector::Protocol::Debugger::CallFrame>::runtimeCast(RefPtr<InspectorValue>&& value)
{
    RefPtr<InspectorObject> result;
    bool castSucceeded = value->asObject(result);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
#if !ASSERT_DISABLED
    BindingTraits<Inspector::Protocol::Debugger::CallFrame>::assertValueHasExpectedType(result.get());
#endif  // !ASSERT_DISABLED
    COMPILE_ASSERT(sizeof(Inspector::Protocol::Debugger::CallFrame) == sizeof(InspectorObjectBase), type_cast_problem);
    return static_cast<Inspector::Protocol::Debugger::CallFrame*>(static_cast<InspectorObjectBase*>(result.get()));
}


#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Debugger::Scope::Type>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    String result;
    bool castSucceeded = value->asString(result);
    ASSERT(castSucceeded);
    ASSERT(result == "global" || result == "with" || result == "closure" || result == "catch" || result == "functionName" || result == "globalLexicalEnvironment" || result == "nestedLexical");
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Debugger::Scope>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator typePos = object->find(ASCIILiteral("type"));
        ASSERT(typePos != object->end());
        BindingTraits<Inspector::Protocol::Debugger::Scope::Type>::assertValueHasExpectedType(typePos->value.get());
    }
    {
        InspectorObject::iterator objectPos = object->find(ASCIILiteral("object"));
        ASSERT(objectPos != object->end());
        BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(objectPos->value.get());
    }

    int foundPropertiesCount = 2;
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::RemoteObject::Type>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    String result;
    bool castSucceeded = value->asString(result);
    ASSERT(castSucceeded);
    ASSERT(result == "object" || result == "function" || result == "undefined" || result == "string" || result == "number" || result == "boolean" || result == "symbol");
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::RemoteObject::Subtype>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    String result;
    bool castSucceeded = value->asString(result);
    ASSERT(castSucceeded);
    ASSERT(result == "array" || result == "null" || result == "node" || result == "regexp" || result == "date" || result == "error" || result == "map" || result == "set" || result == "weakmap" || result == "weakset" || result == "iterator" || result == "class");
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator typePos = object->find(ASCIILiteral("type"));
        ASSERT(typePos != object->end());
        BindingTraits<Inspector::Protocol::Runtime::RemoteObject::Type>::assertValueHasExpectedType(typePos->value.get());
    }

    int foundPropertiesCount = 1;
    {
        InspectorObject::iterator subtypePos = object->find(ASCIILiteral("subtype"));
        if (subtypePos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::RemoteObject::Subtype>::assertValueHasExpectedType(subtypePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator classNamePos = object->find(ASCIILiteral("className"));
        if (classNamePos != object->end()) {
            BindingTraits<String>::assertValueHasExpectedType(classNamePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator valuePos = object->find(ASCIILiteral("value"));
        if (valuePos != object->end()) {
            BindingTraits<Inspector::InspectorValue>::assertValueHasExpectedType(valuePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator descriptionPos = object->find(ASCIILiteral("description"));
        if (descriptionPos != object->end()) {
            BindingTraits<String>::assertValueHasExpectedType(descriptionPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator objectIdPos = object->find(ASCIILiteral("objectId"));
        if (objectIdPos != object->end()) {
            BindingTraits<String>::assertValueHasExpectedType(objectIdPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator sizePos = object->find(ASCIILiteral("size"));
        if (sizePos != object->end()) {
            BindingTraits<int>::assertValueHasExpectedType(sizePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator classPrototypePos = object->find(ASCIILiteral("classPrototype"));
        if (classPrototypePos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(classPrototypePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator previewPos = object->find(ASCIILiteral("preview"));
        if (previewPos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::ObjectPreview>::assertValueHasExpectedType(previewPos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

RefPtr<Inspector::Protocol::Runtime::RemoteObject> BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::runtimeCast(RefPtr<InspectorValue>&& value)
{
    RefPtr<InspectorObject> result;
    bool castSucceeded = value->asObject(result);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
#if !ASSERT_DISABLED
    BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(result.get());
#endif  // !ASSERT_DISABLED
    COMPILE_ASSERT(sizeof(Inspector::Protocol::Runtime::RemoteObject) == sizeof(InspectorObjectBase), type_cast_problem);
    return static_cast<Inspector::Protocol::Runtime::RemoteObject*>(static_cast<InspectorObjectBase*>(result.get()));
}


#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::ObjectPreview::Type>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    String result;
    bool castSucceeded = value->asString(result);
    ASSERT(castSucceeded);
    ASSERT(result == "object" || result == "function" || result == "undefined" || result == "string" || result == "number" || result == "boolean" || result == "symbol");
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::ObjectPreview::Subtype>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    String result;
    bool castSucceeded = value->asString(result);
    ASSERT(castSucceeded);
    ASSERT(result == "array" || result == "null" || result == "node" || result == "regexp" || result == "date" || result == "error" || result == "map" || result == "set" || result == "weakmap" || result == "weakset" || result == "iterator" || result == "class");
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::ObjectPreview>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator typePos = object->find(ASCIILiteral("type"));
        ASSERT(typePos != object->end());
        BindingTraits<Inspector::Protocol::Runtime::ObjectPreview::Type>::assertValueHasExpectedType(typePos->value.get());
    }
    {
        InspectorObject::iterator losslessPos = object->find(ASCIILiteral("lossless"));
        ASSERT(losslessPos != object->end());
        BindingTraits<bool>::assertValueHasExpectedType(losslessPos->value.get());
    }

    int foundPropertiesCount = 2;
    {
        InspectorObject::iterator subtypePos = object->find(ASCIILiteral("subtype"));
        if (subtypePos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::ObjectPreview::Subtype>::assertValueHasExpectedType(subtypePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator descriptionPos = object->find(ASCIILiteral("description"));
        if (descriptionPos != object->end()) {
            BindingTraits<String>::assertValueHasExpectedType(descriptionPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator overflowPos = object->find(ASCIILiteral("overflow"));
        if (overflowPos != object->end()) {
            BindingTraits<bool>::assertValueHasExpectedType(overflowPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator propertiesPos = object->find(ASCIILiteral("properties"));
        if (propertiesPos != object->end()) {
            BindingTraits<Inspector::Protocol::Array<Inspector::Protocol::Runtime::PropertyPreview>>::assertValueHasExpectedType(propertiesPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator entriesPos = object->find(ASCIILiteral("entries"));
        if (entriesPos != object->end()) {
            BindingTraits<Inspector::Protocol::Array<Inspector::Protocol::Runtime::EntryPreview>>::assertValueHasExpectedType(entriesPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator sizePos = object->find(ASCIILiteral("size"));
        if (sizePos != object->end()) {
            BindingTraits<int>::assertValueHasExpectedType(sizePos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

RefPtr<Inspector::Protocol::Runtime::ObjectPreview> BindingTraits<Inspector::Protocol::Runtime::ObjectPreview>::runtimeCast(RefPtr<InspectorValue>&& value)
{
    RefPtr<InspectorObject> result;
    bool castSucceeded = value->asObject(result);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
#if !ASSERT_DISABLED
    BindingTraits<Inspector::Protocol::Runtime::ObjectPreview>::assertValueHasExpectedType(result.get());
#endif  // !ASSERT_DISABLED
    COMPILE_ASSERT(sizeof(Inspector::Protocol::Runtime::ObjectPreview) == sizeof(InspectorObjectBase), type_cast_problem);
    return static_cast<Inspector::Protocol::Runtime::ObjectPreview*>(static_cast<InspectorObjectBase*>(result.get()));
}


#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::PropertyPreview::Type>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    String result;
    bool castSucceeded = value->asString(result);
    ASSERT(castSucceeded);
    ASSERT(result == "object" || result == "function" || result == "undefined" || result == "string" || result == "number" || result == "boolean" || result == "symbol" || result == "accessor");
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::PropertyPreview::Subtype>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    String result;
    bool castSucceeded = value->asString(result);
    ASSERT(castSucceeded);
    ASSERT(result == "array" || result == "null" || result == "node" || result == "regexp" || result == "date" || result == "error" || result == "map" || result == "set" || result == "weakmap" || result == "weakset" || result == "iterator" || result == "class");
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::PropertyPreview>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator namePos = object->find(ASCIILiteral("name"));
        ASSERT(namePos != object->end());
        BindingTraits<String>::assertValueHasExpectedType(namePos->value.get());
    }
    {
        InspectorObject::iterator typePos = object->find(ASCIILiteral("type"));
        ASSERT(typePos != object->end());
        BindingTraits<Inspector::Protocol::Runtime::PropertyPreview::Type>::assertValueHasExpectedType(typePos->value.get());
    }

    int foundPropertiesCount = 2;
    {
        InspectorObject::iterator subtypePos = object->find(ASCIILiteral("subtype"));
        if (subtypePos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::PropertyPreview::Subtype>::assertValueHasExpectedType(subtypePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator valuePos = object->find(ASCIILiteral("value"));
        if (valuePos != object->end()) {
            BindingTraits<String>::assertValueHasExpectedType(valuePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator valuePreviewPos = object->find(ASCIILiteral("valuePreview"));
        if (valuePreviewPos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::ObjectPreview>::assertValueHasExpectedType(valuePreviewPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator internalPos = object->find(ASCIILiteral("internal"));
        if (internalPos != object->end()) {
            BindingTraits<bool>::assertValueHasExpectedType(internalPos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::EntryPreview>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator valuePos = object->find(ASCIILiteral("value"));
        ASSERT(valuePos != object->end());
        BindingTraits<Inspector::Protocol::Runtime::ObjectPreview>::assertValueHasExpectedType(valuePos->value.get());
    }

    int foundPropertiesCount = 1;
    {
        InspectorObject::iterator keyPos = object->find(ASCIILiteral("key"));
        if (keyPos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::ObjectPreview>::assertValueHasExpectedType(keyPos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::CollectionEntry>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator valuePos = object->find(ASCIILiteral("value"));
        ASSERT(valuePos != object->end());
        BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(valuePos->value.get());
    }

    int foundPropertiesCount = 1;
    {
        InspectorObject::iterator keyPos = object->find(ASCIILiteral("key"));
        if (keyPos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(keyPos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

RefPtr<Inspector::Protocol::Runtime::CollectionEntry> BindingTraits<Inspector::Protocol::Runtime::CollectionEntry>::runtimeCast(RefPtr<InspectorValue>&& value)
{
    RefPtr<InspectorObject> result;
    bool castSucceeded = value->asObject(result);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
#if !ASSERT_DISABLED
    BindingTraits<Inspector::Protocol::Runtime::CollectionEntry>::assertValueHasExpectedType(result.get());
#endif  // !ASSERT_DISABLED
    COMPILE_ASSERT(sizeof(Inspector::Protocol::Runtime::CollectionEntry) == sizeof(InspectorObjectBase), type_cast_problem);
    return static_cast<Inspector::Protocol::Runtime::CollectionEntry*>(static_cast<InspectorObjectBase*>(result.get()));
}


#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::PropertyDescriptor>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator namePos = object->find(ASCIILiteral("name"));
        ASSERT(namePos != object->end());
        BindingTraits<String>::assertValueHasExpectedType(namePos->value.get());
    }
    {
        InspectorObject::iterator configurablePos = object->find(ASCIILiteral("configurable"));
        ASSERT(configurablePos != object->end());
        BindingTraits<bool>::assertValueHasExpectedType(configurablePos->value.get());
    }
    {
        InspectorObject::iterator enumerablePos = object->find(ASCIILiteral("enumerable"));
        ASSERT(enumerablePos != object->end());
        BindingTraits<bool>::assertValueHasExpectedType(enumerablePos->value.get());
    }

    int foundPropertiesCount = 3;
    {
        InspectorObject::iterator valuePos = object->find(ASCIILiteral("value"));
        if (valuePos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(valuePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator writablePos = object->find(ASCIILiteral("writable"));
        if (writablePos != object->end()) {
            BindingTraits<bool>::assertValueHasExpectedType(writablePos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator getPos = object->find(ASCIILiteral("get"));
        if (getPos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(getPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator setPos = object->find(ASCIILiteral("set"));
        if (setPos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(setPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator wasThrownPos = object->find(ASCIILiteral("wasThrown"));
        if (wasThrownPos != object->end()) {
            BindingTraits<bool>::assertValueHasExpectedType(wasThrownPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator isOwnPos = object->find(ASCIILiteral("isOwn"));
        if (isOwnPos != object->end()) {
            BindingTraits<bool>::assertValueHasExpectedType(isOwnPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator symbolPos = object->find(ASCIILiteral("symbol"));
        if (symbolPos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(symbolPos->value.get());
            ++foundPropertiesCount;
        }
    }
    {
        InspectorObject::iterator nativeGetterPos = object->find(ASCIILiteral("nativeGetter"));
        if (nativeGetterPos != object->end()) {
            BindingTraits<bool>::assertValueHasExpectedType(nativeGetterPos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

RefPtr<Inspector::Protocol::Runtime::PropertyDescriptor> BindingTraits<Inspector::Protocol::Runtime::PropertyDescriptor>::runtimeCast(RefPtr<InspectorValue>&& value)
{
    RefPtr<InspectorObject> result;
    bool castSucceeded = value->asObject(result);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
#if !ASSERT_DISABLED
    BindingTraits<Inspector::Protocol::Runtime::PropertyDescriptor>::assertValueHasExpectedType(result.get());
#endif  // !ASSERT_DISABLED
    COMPILE_ASSERT(sizeof(Inspector::Protocol::Runtime::PropertyDescriptor) == sizeof(InspectorObjectBase), type_cast_problem);
    return static_cast<Inspector::Protocol::Runtime::PropertyDescriptor*>(static_cast<InspectorObjectBase*>(result.get()));
}


#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Runtime::InternalPropertyDescriptor>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator namePos = object->find(ASCIILiteral("name"));
        ASSERT(namePos != object->end());
        BindingTraits<String>::assertValueHasExpectedType(namePos->value.get());
    }

    int foundPropertiesCount = 1;
    {
        InspectorObject::iterator valuePos = object->find(ASCIILiteral("value"));
        if (valuePos != object->end()) {
            BindingTraits<Inspector::Protocol::Runtime::RemoteObject>::assertValueHasExpectedType(valuePos->value.get());
            ++foundPropertiesCount;
        }
    }
    if (foundPropertiesCount != object->size())
        FATAL("Unexpected properties in object: %s\n", object->toJSONString().ascii().data());
}
#endif // !ASSERT_DISABLED

RefPtr<Inspector::Protocol::Runtime::InternalPropertyDescriptor> BindingTraits<Inspector::Protocol::Runtime::InternalPropertyDescriptor>::runtimeCast(RefPtr<InspectorValue>&& value)
{
    RefPtr<InspectorObject> result;
    bool castSucceeded = value->asObject(result);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
#if !ASSERT_DISABLED
    BindingTraits<Inspector::Protocol::Runtime::InternalPropertyDescriptor>::assertValueHasExpectedType(result.get());
#endif  // !ASSERT_DISABLED
    COMPILE_ASSERT(sizeof(Inspector::Protocol::Runtime::InternalPropertyDescriptor) == sizeof(InspectorObjectBase), type_cast_problem);
    return static_cast<Inspector::Protocol::Runtime::InternalPropertyDescriptor*>(static_cast<InspectorObjectBase*>(result.get()));
}


#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Timeline::EventType>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    String result;
    bool castSucceeded = value->asString(result);
    ASSERT(castSucceeded);
    ASSERT(result == "EventDispatch" || result == "ScheduleStyleRecalculation" || result == "RecalculateStyles" || result == "InvalidateLayout" || result == "Layout" || result == "Paint" || result == "Composite" || result == "RenderingFrame" || result == "TimerInstall" || result == "TimerRemove" || result == "TimerFire" || result == "EvaluateScript" || result == "TimeStamp" || result == "Time" || result == "TimeEnd" || result == "FunctionCall" || result == "ProbeSample" || result == "ConsoleProfile" || result == "RequestAnimationFrame" || result == "CancelAnimationFrame" || result == "FireAnimationFrame");
}
#endif // !ASSERT_DISABLED

#if !ASSERT_DISABLED
void BindingTraits<Inspector::Protocol::Timeline::TimelineEvent>::assertValueHasExpectedType(Inspector::InspectorValue* value)
{
    ASSERT_ARG(value, value);
    RefPtr<InspectorObject> object;
    bool castSucceeded = value->asObject(object);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
    {
        InspectorObject::iterator typePos = object->find(ASCIILiteral("type"));
        ASSERT(typePos != object->end());
        BindingTraits<Inspector::Protocol::Timeline::EventType>::assertValueHasExpectedType(typePos->value.get());
    }
    {
        InspectorObject::iterator dataPos = object->find(ASCIILiteral("data"));
        ASSERT(dataPos != object->end());
        BindingTraits<Inspector::InspectorObject>::assertValueHasExpectedType(dataPos->value.get());
    }
    {
        InspectorObject::iterator childrenPos = object->find(ASCIILiteral("children"));
        if (childrenPos != object->end()) {
            BindingTraits<Inspector::Protocol::Array<Inspector::Protocol::Timeline::TimelineEvent>>::assertValueHasExpectedType(childrenPos->value.get());
        }
    }
}
#endif // !ASSERT_DISABLED

RefPtr<Inspector::Protocol::Timeline::TimelineEvent> BindingTraits<Inspector::Protocol::Timeline::TimelineEvent>::runtimeCast(RefPtr<InspectorValue>&& value)
{
    RefPtr<InspectorObject> result;
    bool castSucceeded = value->asObject(result);
    ASSERT_UNUSED(castSucceeded, castSucceeded);
#if !ASSERT_DISABLED
    BindingTraits<Inspector::Protocol::Timeline::TimelineEvent>::assertValueHasExpectedType(result.get());
#endif  // !ASSERT_DISABLED
    COMPILE_ASSERT(sizeof(Inspector::Protocol::Timeline::TimelineEvent) == sizeof(InspectorObjectBase), type_cast_problem);
    return static_cast<Inspector::Protocol::Timeline::TimelineEvent*>(static_cast<InspectorObjectBase*>(result.get()));
}


} // namespace Protocol

} // namespace Inspector
